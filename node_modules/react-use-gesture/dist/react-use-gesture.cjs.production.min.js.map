{"version":3,"file":"react-use-gesture.cjs.production.min.js","sources":["../src/types.ts","../src/utils.ts","../src/defaults.ts","../src/recognizers/Recognizer.ts","../src/recognizers/CoordinatesRecognizer.ts","../src/recognizers/DragRecognizer.ts","../src/recognizers/ScrollRecognizer.ts","../src/recognizers/WheelRecognizer.ts","../src/recognizers/MoveRecognizer.ts","../src/recognizers/HoverRecognizer.ts","../src/recognizers/DistanceAngleRecognizer.ts","../src/recognizers/PinchRecognizer.ts","../src/recognizers/PinchWheelRecognizer.ts","../src/recognizers/PinchWebKitGestureRecognizer.ts","../src/controllers/GestureController.ts","../src/hooks.ts"],"sourcesContent":["import React from 'react'\n\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>\nexport type AtLeastOneOf<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> & U[keyof U]\n\nexport type Vector2 = [number, number]\nexport type Fn = (...args: any[]) => any\n\nexport type EventOptions = { capture?: boolean; passive?: boolean }\n\nexport interface GestureConfig {\n  domTarget?: EventTarget | React.RefObject<EventTarget> | null\n  event: EventOptions\n  window?: EventTarget\n  dragDelay: boolean | number\n  passiveEvents: boolean\n  pointerEvents: boolean\n  enabled: boolean\n  drag: boolean\n  pinch: boolean\n  scroll: boolean\n  wheel: boolean\n  hover: boolean\n  move: boolean\n}\n\nexport enum GestureFlag {\n  OnStart = 'start',\n  OnChange = 'change',\n  OnEnd = 'end',\n}\n\nexport type WebKitGestureEvent = React.PointerEvent & { scale: number; rotation: number }\nexport type UseGestureEvent<\n  T extends React.SyntheticEvent = React.MouseEvent | React.TouchEvent | React.WheelEvent | React.PointerEvent | WebKitGestureEvent\n> = T & {\n  gesture?: GestureKey\n}\n\nexport interface ReactEventHandlers {\n  // Mouse Events\n  onMouseDown?: React.MouseEventHandler\n  onMouseDownCapture?: React.MouseEventHandler\n  onMouseEnter?: React.MouseEventHandler\n  onMouseLeave?: React.MouseEventHandler\n  onMouseMove?: React.MouseEventHandler\n  onMouseMoveCapture?: React.MouseEventHandler\n  onMouseOut?: React.MouseEventHandler\n  onMouseOutCapture?: React.MouseEventHandler\n  onMouseOver?: React.MouseEventHandler\n  onMouseOverCapture?: React.MouseEventHandler\n  onMouseUp?: React.MouseEventHandler\n  onMouseUpCapture?: React.MouseEventHandler\n  // Touch Events\n  onTouchCancel?: React.TouchEventHandler\n  onTouchCancelCapture?: React.TouchEventHandler\n  onTouchEnd?: React.TouchEventHandler\n  onTouchEndCapture?: React.TouchEventHandler\n  onTouchMove?: React.TouchEventHandler\n  onTouchMoveCapture?: React.TouchEventHandler\n  onTouchStart?: React.TouchEventHandler\n  onTouchStartCapture?: React.TouchEventHandler\n\n  // Pointer Events\n  onPointerDown?: React.PointerEventHandler\n  onPointerDownCapture?: React.PointerEventHandler\n  onPointerMove?: React.PointerEventHandler\n  onPointerMoveCapture?: React.PointerEventHandler\n  onPointerUp?: React.PointerEventHandler\n  onPointerUpCapture?: React.PointerEventHandler\n  onPointerCancel?: React.PointerEventHandler\n  onPointerCancelCapture?: React.PointerEventHandler\n  onPointerEnter?: React.PointerEventHandler\n  onPointerEnterCapture?: React.PointerEventHandler\n  onPointerLeave?: React.PointerEventHandler\n  onPointerLeaveCapture?: React.PointerEventHandler\n  onPointerOver?: React.PointerEventHandler\n  onPointerOverCapture?: React.PointerEventHandler\n  onPointerOut?: React.PointerEventHandler\n  onPointerOutCapture?: React.PointerEventHandler\n  onGotPointerCapture?: React.PointerEventHandler\n  onGotPointerCaptureCapture?: React.PointerEventHandler\n  onLostPointerCapture?: React.PointerEventHandler\n  onLostPointerCaptureCapture?: React.PointerEventHandler\n\n  // UI Events\n  onScroll?: React.UIEventHandler\n  onScrollCapture?: React.UIEventHandler\n\n  // Wheel Events\n  onWheel?: React.WheelEventHandler\n  onWheelCapture?: React.WheelEventHandler\n\n  // Cheat mode for Gesture Events\n  onGestureStart?: Fn\n  onGestureChange?: Fn\n  onGestureEnd?: Fn\n}\n\nexport type ReactEventHandlerKey = keyof ReactEventHandlers\n\nexport type GestureKey = 'drag' | 'pinch' | 'move' | 'scroll' | 'wheel' | 'hover'\nexport type StateKey = Exclude<GestureKey, 'hover'>\n\nexport interface SharedGestureState {\n  hovering: boolean\n  scrolling: boolean\n  wheeling: boolean\n  dragging: boolean\n  moving: boolean\n  pinching: boolean\n  touches: number\n  down: boolean\n  buttons: number\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  ctrlKey: boolean\n}\n\nexport interface CommonGestureState {\n  event?: UseGestureEvent\n  currentTarget?: EventTarget | null\n  pointerId?: number | null\n  values: Vector2\n  delta: Vector2\n  movement: Vector2\n  offset: Vector2\n  initial: Vector2\n  previous: Vector2\n  direction: Vector2\n  first: boolean\n  last: boolean\n  active: boolean\n  time?: number\n  cancel?(): void\n  canceled: boolean\n  memo?: any\n  args?: any\n}\n\nexport interface Coordinates {\n  xy: Vector2\n  velocity: number\n  vxvy: Vector2\n  distance: number\n}\n\nexport interface DistanceAngle {\n  da: Vector2\n  vdva: Vector2\n  origin?: Vector2\n  turns: number\n}\n\nexport type GestureState<T extends Coordinates | DistanceAngle = Coordinates | DistanceAngle> = T & CommonGestureState\nexport type FullGestureState<T extends Coordinates | DistanceAngle> = SharedGestureState & GestureState<T>\n\nexport type StateObject = { shared: SharedGestureState } & { [K in StateKey]: GestureState<Coordinates | DistanceAngle> }\n\nexport type Handler<T extends Coordinates | DistanceAngle> = (state: FullGestureState<T>) => any | void\nexport type HandlerKey = 'onDrag' | 'onPinch' | 'onMove' | 'onHover' | 'onScroll' | 'onWheel'\n\nexport type GestureHandlers = {\n  onDrag: Handler<Coordinates>\n  onDragStart: Handler<Coordinates>\n  onDragEnd: Handler<Coordinates>\n  onHover: Handler<Coordinates>\n  onMove: Handler<Coordinates>\n  onMoveStart: Handler<Coordinates>\n  onMoveEnd: Handler<Coordinates>\n  onScroll: Handler<Coordinates>\n  onScrollStart: Handler<Coordinates>\n  onScrollEnd: Handler<Coordinates>\n  onWheel: Handler<Coordinates>\n  onWheelStart: Handler<Coordinates>\n  onWheelEnd: Handler<Coordinates>\n  onPinch: Handler<DistanceAngle>\n  onPinchStart: Handler<DistanceAngle>\n  onPinchEnd: Handler<DistanceAngle>\n}\n\n/* Handlers should also accept DomAttributes to prevent overrides */\nexport type GestureHandlersPartial = AtLeastOneOf<GestureHandlers> &\n  Partial<Omit<React.DOMAttributes<Element>, 'onDrag' | 'onScroll' | 'onWheel'>>\n","import React from 'react'\nimport { Fn, Vector2, EventOptions, Coordinates, FullGestureState, DistanceAngle, UseGestureEvent } from './types'\n\n// blank function\nexport const noop = () => {}\n\n// returns a function that chains all functions given as parameters\nexport const chainFns = (...fns: Fn[]): Fn => (...args: any[]) => fns.forEach(fn => fn(...args))\n\n// vector add\nexport const addV = <T extends number[]>(v1: T, v2: T): T => <T>v1.map((v, i) => v + v2[i])\n\n// vector substract\nexport const subV = <T extends number[]>(v1: T, v2: T): T => <T>v1.map((v, i) => v - v2[i])\n\nconst setListeners = (add: boolean) => (el: EventTarget, listeners: [string, Fn][], options: EventOptions): void => {\n  const action = add ? 'addEventListener' : 'removeEventListener'\n  listeners.forEach(([type, fn]) => el[action](type, fn, options))\n}\n\nexport const addListeners = setListeners(true)\nexport const removeListeners = setListeners(false)\n\ninterface ModifierKeys {\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  ctrlKey: boolean\n}\n\n/**\n * Gets modifier keys from event\n * @param event\n * @returns modifier keys\n */\nexport function getModifierKeys(event: UseGestureEvent): ModifierKeys {\n  const { shiftKey, altKey, metaKey, ctrlKey } = event\n  return { shiftKey, altKey, metaKey, ctrlKey }\n}\ntype ScrollEventData = Pick<FullGestureState<Coordinates>, 'xy'> & ModifierKeys\n\n/**\n * Gets scroll event data\n * @param event\n * @returns scroll event data\n */\nexport function getScrollEventData(event: UseGestureEvent): ScrollEventData {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  const { scrollX, scrollY, scrollLeft, scrollTop } = <Element & Window>event.currentTarget\n  return { xy: [scrollX || scrollLeft || 0, scrollY || scrollTop || 0], ...getModifierKeys(event) }\n}\n\ntype WheelEventData = Pick<FullGestureState<Coordinates>, 'xy'> & ModifierKeys\n\n/**\n * Gets wheel event data\n * @param event\n * @returns wheel event data\n */\nexport function getWheelEventData(event: UseGestureEvent<React.WheelEvent>): WheelEventData {\n  const { deltaX, deltaY } = event\n  //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n  return { xy: [deltaX, deltaY], ...getModifierKeys(event) }\n}\n\ntype PointerEventData = Pick<FullGestureState<Coordinates>, 'xy' | 'touches' | 'down' | 'buttons'> & ModifierKeys\n/**\n * Gets pointer event data\n * @param event\n * @returns pointer event data\n */\nexport function getPointerEventData(event: React.MouseEvent | React.TouchEvent | React.PointerEvent): PointerEventData {\n  const { touches, buttons, changedTouches } = event as any\n  const touchEvents = touches && touches.length > 0 ? touches : changedTouches && changedTouches.length > 0 ? changedTouches : null\n  const { clientX, clientY } = touchEvents ? touchEvents[0] : event\n  const down = (touchEvents && touchEvents.length > 0) || buttons > 0\n  return {\n    xy: [clientX, clientY],\n    touches: (touchEvents && touchEvents.length) || 0,\n    down,\n    buttons,\n    ...getModifierKeys(event),\n  }\n}\n\ntype TwoTouchesEventData = Pick<FullGestureState<DistanceAngle>, 'da' | 'touches' | 'down' | 'origin'> & ModifierKeys\n\n/**\n * Gets two touches event data\n * @param event\n * @returns two touches event data\n */\nexport function getTwoTouchesEventData(event: React.TouchEvent): TwoTouchesEventData {\n  const { touches } = event\n  const dx = touches[1].clientX - touches[0].clientX\n  const dy = touches[1].clientY - touches[0].clientY\n\n  const da: Vector2 = [Math.hypot(dx, dy), -(Math.atan2(dx, dy) * 180) / Math.PI]\n  const origin: Vector2 = [(touches[1].clientX + touches[0].clientX) / 2, (touches[1].clientY + touches[0].clientY) / 2]\n\n  return { da, origin, touches: 2, down: touches.length > 0, ...getModifierKeys(event) }\n}\n\n/**\n * Calculates velocity\n * @param delta the difference between current and previous vectors\n * @param delta_t the time offset\n * @param len the length of the delta vector\n * @returns velocity\n */\nexport function calculateVelocity(delta: number[], delta_t: number, len: number): number {\n  len = len || Math.hypot(...delta)\n  return delta_t ? len / delta_t : 0\n}\n\n/**\n * Calculates velocities vector\n * @template T the expected vector type\n * @param delta the difference between current and previous vectors\n * @param delta_t the time offset\n * @returns velocities vector\n */\nexport function calculateVelocities<T extends number[]>(delta: T, delta_t: number): T {\n  return delta_t ? <T>delta.map(v => v / delta_t) : <T>Array(delta.length).fill(0)\n}\n\n/**\n * Calculates distance\n * @param movement the difference between current and initial vectors\n * @returns distance\n */\nexport function calculateDistance(movement: number[]): number {\n  return Math.hypot(...movement)\n}\n\n/**\n * Calculates direction\n * @template T the expected vector type\n * @param delta\n * @param len\n * @returns direction\n */\nexport function calculateDirection<T extends number[]>(delta: T, len?: number): T {\n  len = len || Math.hypot(...delta) || 1\n  return <T>delta.map(v => v / len!)\n}\n\ninterface Kinematics<T extends number[]> {\n  velocities: T\n  velocity: number\n  distance: number\n  direction: T\n}\n\n/**\n * Calculates all kinematics\n * @template T the expected vector type\n * @param movement the difference between current and initial vectors\n * @param delta the difference between current and previous vectors\n * @param delta_t the time difference between current and previous timestamps\n * @returns all kinematics\n */\nexport function calculateAllKinematics<T extends number[]>(movement: T, delta: T, delta_t: number): Kinematics<T> {\n  const len = Math.hypot(...delta)\n\n  return {\n    velocities: calculateVelocities(delta, delta_t),\n    velocity: calculateVelocity(delta, delta_t, len),\n    distance: calculateDistance(movement),\n    direction: calculateDirection(delta, len),\n  }\n}\n\n/**\n * Whether the browser supports GestureEvent (ie Safari)\n * @returns true if the browser supports gesture event\n */\nexport function gestureEventSupported(): boolean {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: Unreachable code error\n    return 'constructor' in GestureEvent\n  } catch (e) {\n    return false\n  }\n}\n","import { noop } from './utils'\nimport { GestureConfig, HandlerKey, CommonGestureState, Coordinates, DistanceAngle, StateObject, StateKey, GestureKey } from './types'\n\ntype MappedKeys = { [K in GestureKey]: { stateKey: StateKey; handlerKey: HandlerKey } }\n\n/**\n * Some gestures might use the state key from another gesture (i.e. hover)\n * so mappedKeys is a commodity object to get the state key and handler key\n * for every gesture\n */\nexport const mappedKeys: MappedKeys = {\n  drag: { stateKey: 'drag', handlerKey: 'onDrag' },\n  pinch: { stateKey: 'pinch', handlerKey: 'onPinch' },\n  move: { stateKey: 'move', handlerKey: 'onMove' },\n  scroll: { stateKey: 'scroll', handlerKey: 'onScroll' },\n  wheel: { stateKey: 'wheel', handlerKey: 'onWheel' },\n  hover: { stateKey: 'move', handlerKey: 'onHover' },\n}\n\n// default config (will extend user config)\nexport const defaultConfig: GestureConfig = {\n  domTarget: undefined,\n  event: { passive: true, capture: false },\n  window: typeof window !== 'undefined' ? window : undefined,\n  dragDelay: false,\n  passiveEvents: true,\n  pointerEvents: false,\n  enabled: true,\n  drag: true,\n  pinch: true,\n  scroll: true,\n  wheel: true,\n  hover: true,\n  move: true,\n}\n\n// common initial state for all gestures\nexport const initialCommon: CommonGestureState = {\n  event: undefined,\n  currentTarget: undefined,\n  pointerId: undefined,\n  values: [0, 0],\n  delta: [0, 0],\n  movement: [0, 0],\n  offset: [0, 0],\n  direction: [0, 0],\n  initial: [0, 0],\n  previous: [0, 0],\n  first: false,\n  last: false,\n  active: false,\n  time: undefined,\n  cancel: noop,\n  canceled: false,\n  memo: undefined,\n  args: undefined,\n}\n\n// initial state for coordinates-based gestures\nconst initialCoordinates: Coordinates = { xy: [0, 0], vxvy: [0, 0], velocity: 0, distance: 0 } // xy coordinates\n\n// initial state for distance and angle-based gestures (pinch)\nconst initialDistanceAngle: DistanceAngle = { da: [0, 0], vdva: [0, 0], origin: undefined, turns: 0 } // distance and angle\n\n// initial state object (used by the gesture controller)\nexport const initialState: StateObject = {\n  shared: {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false,\n  },\n  move: { ...initialCommon, ...initialCoordinates },\n  drag: { ...initialCommon, ...initialCoordinates },\n  scroll: { ...initialCommon, ...initialCoordinates },\n  wheel: { ...initialCommon, ...initialCoordinates },\n  pinch: { ...initialCommon, ...initialDistanceAngle },\n}\n\n// generic end state for all gestures\nexport const genericEndState: Partial<CommonGestureState> = { first: false, last: true, active: false }\n","import { mappedKeys, genericEndState, initialState } from '../defaults'\nimport GestureController from '../controllers/GestureController'\nimport {\n  Coordinates,\n  DistanceAngle,\n  StateKey,\n  GestureState,\n  GestureKey,\n  SharedGestureState,\n  Fn,\n  ReactEventHandlerKey,\n  GestureFlag,\n  UseGestureEvent,\n  Vector2,\n} from '../types'\nimport { noop, subV, calculateAllKinematics } from '../utils'\n\ntype PayloadFromEvent = {\n  values: Vector2\n  gesturePayload?: Partial<GestureState>\n  sharedPayload?: Partial<SharedGestureState>\n}\n\n/**\n * Recognizer abstract class\n * @template GestureType whether the Recognizer should deal with coordinates or distance / angle\n */\nexport default abstract class Recognizer<GestureType extends Coordinates | DistanceAngle = Coordinates | DistanceAngle> {\n  protected stateKey: StateKey\n  protected sharedStartState?: Partial<SharedGestureState>\n  protected sharedEndState?: Partial<SharedGestureState>\n\n  /**\n   * Continuous gestures are scroll or wheel, where the next gesture continues the previous one.\n   * In other words, these gestures also start with a delta.\n   */\n  protected continuousGesture = false\n\n  /**\n   * Creates an instance of a gesture recognizer.\n   * @param gestureKey drag, move, hover, pinch, etc.\n   * @param controller the controller attached to the gesture\n   * @param [args] the args that should be passed to the gesture handler\n   */\n  constructor(\n    protected readonly gestureKey: GestureKey,\n    protected readonly controller: GestureController,\n    protected readonly args: any[] = []\n  ) {\n    // mapping this.stateKey to the state key the gesture handles\n    // (ie hover actually deals with the move gesture state)\n    this.stateKey = mappedKeys[gestureKey].stateKey\n  }\n\n  // is the gesture enabled\n  protected get enabled(): boolean {\n    return this.controller.config.enabled && this.controller.config[this.gestureKey]\n  }\n  // get the controller state for a given gesture\n  protected get state() {\n    return this.controller.state[this.stateKey] as GestureState<GestureType>\n  }\n\n  // convenience method to set a timeout for a given gesture\n  protected setTimeout = (callback: (...args: any[]) => void, ms: number = 140, ...args: any[]): void => {\n    this.controller.timeouts[this.stateKey] = window.setTimeout(callback, ms, ...args)\n  }\n\n  // convenience method to clear a timeout for a given gesture\n  protected clearTimeout = () => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n  }\n\n  // convenience method to add window listeners for a given gesture\n  protected addWindowListeners = (listeners: [string, Fn][]) => {\n    this.controller.addWindowListeners(this.stateKey, listeners)\n  }\n\n  // convenience method to remove window listeners for a given gesture\n  protected removeWindowListeners = () => {\n    this.controller.removeWindowListeners(this.stateKey)\n  }\n\n  protected abstract getPayloadFromEvent(event: UseGestureEvent): PayloadFromEvent\n\n  /**\n   * Utility function to get kinematics of the gesture\n   * @values values we want to calculate the kinematics from\n   * @event\n   * @returns set of values including movement, velocity, velocities, distance and direction\n   */\n  protected abstract getKinematics(values: [number, number | undefined], event: UseGestureEvent): Partial<GestureState<GestureType>>\n\n  // should return the bindings for a given gesture\n  public abstract getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][]\n\n  /**\n   * convenience method to update the controller state for a given gesture\n   * @param sharedState shared partial state object\n   * @param gestureState partial state object for the gesture handled by the recognizer\n   * @param [gestureFlag] if set, will also fire the gesture handler set by the user\n   */\n  protected updateState = (sharedState: Partial<SharedGestureState> | null, gestureState: Partial<GestureState<GestureType>>): void => {\n    this.controller.updateState(sharedState, gestureState, this.stateKey)\n  }\n\n  protected fireGestureHandler = (gestureFlag: GestureFlag): void => {\n    this.controller.fireGestureHandler(this.gestureKey, gestureFlag)\n  }\n\n  // generic onStart function\n  protected onStart = (event: UseGestureEvent, payload?: Partial<GestureState<GestureType>>): void => {\n    const { values, gesturePayload, sharedPayload } = this.getPayloadFromEvent(event)\n\n    // TODO probably needs some rework, initialState and resetState should be different\n\n    const startState: GestureState<GestureType> = {\n      ...(initialState[this.stateKey] as GestureState<GestureType>),\n      values,\n      event,\n      first: true,\n      active: true,\n      time: event.timeStamp,\n      args: this.args,\n    }\n\n    const { values: prevValues, offset } = this.state\n\n    if (this.continuousGesture) {\n      startState.initial = startState.previous = prevValues\n      startState.delta = startState.movement = subV(values, prevValues)\n      startState.offset = values\n      Object.assign(startState, calculateAllKinematics(startState.movement, startState.delta, 0))\n    } else {\n      startState.initial = startState.previous = values\n      startState.offset = offset\n    }\n\n    this.updateState({ ...this.sharedStartState, ...sharedPayload }, { ...startState, ...gesturePayload, ...payload })\n    this.fireGestureHandler(GestureFlag.OnStart)\n  }\n\n  // generic onChange function\n  protected onChange = (event: UseGestureEvent, payload?: Partial<GestureState<GestureType>>): void => {\n    const { values, gesturePayload, sharedPayload } = this.getPayloadFromEvent(event)\n    const kinematics = this.getKinematics(values, event)\n    this.updateState({ ...sharedPayload }, { first: false, ...kinematics, ...gesturePayload, ...payload })\n    this.fireGestureHandler(GestureFlag.OnChange)\n  }\n\n  // generic onEnd function\n  protected onEnd = (event: UseGestureEvent, payload?: Partial<GestureState<GestureType>>): void => {\n    if (!this.state.active) return\n    this.removeWindowListeners()\n    this.updateState(this.sharedEndState!, { event, ...genericEndState, ...payload } as Partial<GestureState<GestureType>>)\n    this.fireGestureHandler(GestureFlag.OnEnd)\n  }\n\n  // generic cancel function\n  protected onCancel = (event: UseGestureEvent): void => {\n    this.updateState(null, { canceled: true, cancel: noop } as Partial<GestureState<GestureType>>)\n    requestAnimationFrame(() => this.onEnd(event))\n  }\n\n  // generic gesture handler for timeout-based gestures\n  protected timeoutHandler = (event: UseGestureEvent) => {\n    if (!this.enabled) return\n\n    this.clearTimeout()\n    this.setTimeout(this.onEnd)\n\n    if (!this.state.active) this.onStart(event)\n    else this.onChange(event)\n  }\n}\n","import Recognizer from './Recognizer'\nimport { addV, subV, calculateAllKinematics } from '../utils'\nimport { Coordinates, GestureState, Vector2, UseGestureEvent } from '../types'\n\n/**\n * Abstract class for coordinates-based gesture recongizers\n */\nexport default abstract class CoordinatesRecognizer extends Recognizer<Coordinates> {\n  getKinematics(values: Vector2, event: UseGestureEvent): Partial<GestureState<Coordinates>> {\n    // we get the gesture specific state\n    const { values: xy, initial, offset, time } = this.state\n\n    // offset is the difference between the current and initial value vectors\n    const movement = subV(values, initial)\n    // delta is the difference between the current and previous value vectors\n    const delta = subV(values, xy)\n\n    const delta_t = event.timeStamp - time!\n    const { velocity, velocities, distance, direction } = calculateAllKinematics(movement, delta, delta_t)\n\n    return {\n      event,\n      values,\n      movement,\n      offset: addV(offset, delta),\n      delta,\n      velocity,\n      vxvy: velocities,\n      distance,\n      direction,\n      previous: xy,\n      time: event.timeStamp,\n    }\n  }\n}\n","import { PointerEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getPointerEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { UseGestureEvent, ReactEventHandlerKey, Fn } from '../types'\n\nconst DEFAULT_DRAG_DELAY = 180\n\nexport default class DragRecognizer extends CoordinatesRecognizer {\n  sharedStartState = { dragging: true, down: true }\n  sharedEndState = { dragging: false, down: false, buttons: 0, touches: 0 }\n\n  delayedEvent = false\n\n  constructor(controller: GestureController, args: any[]) {\n    super('drag', controller, args)\n  }\n\n  getPayloadFromEvent(event: UseGestureEvent) {\n    const { xy, ...sharedPayload } = getPointerEventData(event)\n    return { values: xy, sharedPayload }\n  }\n\n  onDragStart = (event: UseGestureEvent): void => {\n    if (!this.enabled) return\n\n    // making sure we're not dragging the element when more than one finger press the screen\n    const { touches } = getPointerEventData(event)\n    if (touches > 1) return\n\n    const { currentTarget, pointerId } = event as PointerEvent\n    if (this.controller.config.pointerEvents) {\n      // if pointers events\n      currentTarget && (currentTarget as any).setPointerCapture(pointerId)\n    } else {\n      this.removeWindowListeners()\n      const dragListeners: [string, Fn][] = [\n        ['mousemove', this.onDragChange],\n        ['touchmove', this.onDragChange],\n        ['mouseup', this.onDragEnd],\n        ['touchend', this.onDragEnd],\n        ['touchcancel', this.onDragEnd],\n      ]\n      this.addWindowListeners(dragListeners)\n    }\n\n    if (this.controller.config.dragDelay) {\n      const dragDelay = typeof this.controller.config.dragDelay === 'number' ? this.controller.config.dragDelay : DEFAULT_DRAG_DELAY\n      if (typeof event.persist === 'function') event.persist()\n      this.delayedEvent = true\n      this.setTimeout(() => this.startDrag(event), dragDelay)\n    } else {\n      this.startDrag(event)\n    }\n  }\n\n  startDrag = (event: UseGestureEvent): void => {\n    const { currentTarget, pointerId } = event as PointerEvent\n    this.onStart(event, { currentTarget, pointerId, cancel: () => this.onCancel(event) })\n    this.delayedEvent = false\n  }\n\n  onDragChange = (event: UseGestureEvent): void => {\n    const { canceled, active } = this.state\n    if (canceled) return\n\n    if (!active) {\n      if (this.delayedEvent) {\n        this.clearTimeout()\n        this.startDrag(event)\n      }\n      return\n    }\n\n    const { buttons, touches } = getPointerEventData(event)\n\n    if (buttons === 0 && touches === 0) {\n      this.onEnd(event)\n      return\n    }\n\n    this.onChange(event, { cancel: () => this.onCancel(event) })\n  }\n\n  onDragEnd = (event: UseGestureEvent): void => {\n    this.clearTimeout()\n    this.delayedEvent = false\n\n    if (!this.state.active) return\n\n    const { currentTarget, pointerId } = this.state\n    if (currentTarget && this.controller.config.pointerEvents) (currentTarget as any).releasePointerCapture(pointerId)\n    this.onEnd(event)\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    if (this.controller.config.pointerEvents) {\n      return [['onPointerDown', this.onDragStart], ['onPointerMove', this.onDragChange], [['onPointerUp'], this.onDragEnd]]\n    }\n    return [[['onMouseDown', 'onTouchStart'], this.onDragStart]]\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getScrollEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { UseGestureEvent, ReactEventHandlerKey, Fn } from '../types'\n\nexport default class ScrollRecognizer extends CoordinatesRecognizer {\n  sharedStartState = { scrolling: true }\n  sharedEndState = { scrolling: false, velocity: 0, vxvy: [0, 0] }\n  continuousGesture = true\n\n  constructor(controller: GestureController, args: any[]) {\n    super('scroll', controller, args)\n  }\n\n  getPayloadFromEvent(event: UseGestureEvent) {\n    const { xy, ...sharedPayload } = getScrollEventData(event)\n    return { values: xy, sharedPayload }\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    return [['onScroll', this.timeoutHandler]]\n  }\n}\n","import { WheelEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { addV, getWheelEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { UseGestureEvent, ReactEventHandlerKey, Fn } from '../types'\n\nexport default class WheelRecognizer extends CoordinatesRecognizer {\n  sharedStartState = { wheeling: true }\n  sharedEndState = { wheeling: false, velocity: 0, vxvy: [0, 0] }\n  continuousGesture = true\n\n  constructor(controller: GestureController, args: any[]) {\n    super('wheel', controller, args)\n  }\n\n  getPayloadFromEvent(event: UseGestureEvent<WheelEvent>) {\n    const { xy: prevXY } = this.state\n    const { xy, ...sharedPayload } = getWheelEventData(event)\n    const values = addV(xy, prevXY)\n\n    return { values, sharedPayload }\n  }\n\n  onWheel = (event: UseGestureEvent<WheelEvent>): void => {\n    if (event.ctrlKey && this.controller.actions.has('onPinch')) return\n    this.timeoutHandler(event)\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    return [['onWheel', this.onWheel]]\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getPointerEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { UseGestureEvent, ReactEventHandlerKey, Fn } from '../types'\n\nexport default class MoveRecognizer extends CoordinatesRecognizer {\n  sharedStartState = { moving: true }\n  sharedEndState = { moving: false, velocity: 0, vxvy: [0, 0] }\n\n  constructor(controller: GestureController, args: any[]) {\n    super('move', controller, args)\n  }\n\n  getPayloadFromEvent(event: UseGestureEvent) {\n    const { xy, ...sharedPayload } = getPointerEventData(event)\n    return { values: xy, sharedPayload }\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    if (this.controller.config.pointerEvents) {\n      return [['onPointerMove', this.timeoutHandler]]\n    }\n    return [['onMouseMove', this.timeoutHandler]]\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getPointerEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { GestureFlag, UseGestureEvent, ReactEventHandlerKey, Fn } from '../types'\nimport { genericEndState } from '../defaults'\n\nexport default class HoverRecognizer extends CoordinatesRecognizer {\n  constructor(controller: GestureController, args: any[]) {\n    super('hover', controller, args)\n  }\n\n  getPayloadFromEvent(event: UseGestureEvent) {\n    const { xy, ...sharedPayload } = getPointerEventData(event)\n    return { values: xy, sharedPayload }\n  }\n\n  onPointerEnter = (event: UseGestureEvent): void => {\n    if (!this.enabled) return\n    const { values, sharedPayload } = this.getPayloadFromEvent(event)\n    this.updateState({ hovering: true, ...sharedPayload }, { values, event, args: this.args })\n    this.fireGestureHandler(GestureFlag.OnChange)\n  }\n\n  onPointerLeave = (event: UseGestureEvent): void => {\n    if (!this.enabled) return\n    const { values, sharedPayload } = this.getPayloadFromEvent(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateState({ hovering: false, moving: false, ...sharedPayload }, { ...kinematics, ...genericEndState, velocity: 0, vxvy: [0, 0] })\n\n    // when the mouse leaves the element, we also fire the move handler\n    // without waiting for move to end with debounce\n    this.controller.fireGestureHandler('move', GestureFlag.OnEnd)\n    this.controller.fireGestureHandler('hover', GestureFlag.OnChange)\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    if (this.controller.config.pointerEvents) {\n      return [['onPointerEnter', this.onPointerEnter], ['onPointerLeave', this.onPointerLeave]]\n    }\n    return [['onMouseEnter', this.onPointerEnter], ['onMouseLeave', this.onPointerLeave]]\n  }\n}\n","import Recognizer from './Recognizer'\nimport { addV, calculateVelocities, calculateDirection } from '../utils'\nimport { DistanceAngle, GestureState, Vector2, UseGestureEvent, GestureKey } from '../types'\nimport GestureController from '../controllers/GestureController'\n\n/**\n * Abstract class for distance/angle-based gesture recongizers\n */\nexport default abstract class DistanceAngleRecognizer extends Recognizer<DistanceAngle> {\n  constructor(gestureKey: GestureKey, controller: GestureController, args: any[] = []) {\n    super(gestureKey, controller, args)\n  }\n\n  getKinematics([d, a]: [number, number?], event: UseGestureEvent): Partial<GestureState<DistanceAngle>> {\n    const { values: da, turns, initial, offset, time } = this.state\n\n    // angle might not be defined when ctrl wheel is used for zoom only\n    // in that case we set it to the previous angle value\n    a = a !== void 0 ? a : da[1]\n\n    const delta_d = d - da[0]\n    let delta_a = a - da[1]\n\n    /**\n     * The angle value might jump from 179deg to -179deg when we actually want to\n     * read 181deg to ensure continuity. To make that happen, we detect when the jump\n     * is supsiciously high (ie > 270deg) and increase the `turns` value\n     */\n    const newTurns = Math.abs(delta_a) > 270 ? turns + Math.sign(delta_a) : turns\n\n    // we update the angle difference to its corrected value\n    delta_a -= 360 * (newTurns - turns)\n    const delta = [delta_d, delta_a] as Vector2\n\n    const movement_d = d - initial[0]\n    const movement_a = a - 360 * newTurns - initial[1]\n    const movement: Vector2 = [movement_d, movement_a]\n\n    const delta_t = event.timeStamp - time!\n    const vdva = calculateVelocities(delta, delta_t)\n    const direction = calculateDirection(delta)\n    return {\n      event,\n      values: [d, a],\n      movement,\n      delta,\n      offset: addV(offset, delta),\n      vdva,\n      direction,\n      turns: newTurns,\n      previous: da,\n      time: event.timeStamp,\n    }\n  }\n}\n","import { TouchEvent } from 'react'\nimport DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport { getTwoTouchesEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { UseGestureEvent, ReactEventHandlerKey, Fn } from '../types'\n\nexport default class PinchRecognizer extends DistanceAngleRecognizer {\n  sharedStartState = { pinching: true }\n  sharedEndState = { pinching: false, down: false, touches: 0 }\n\n  constructor(controller: GestureController, args: any[]) {\n    super('pinch', controller, args)\n  }\n\n  getPayloadFromEvent(event: UseGestureEvent<TouchEvent>) {\n    const { da, origin, ...sharedPayload } = getTwoTouchesEventData(event)\n    return { values: da, gesturePayload: { origin }, sharedPayload }\n  }\n\n  onPinchStart = (event: UseGestureEvent<TouchEvent>): void => {\n    if (!this.enabled || event.touches.length !== 2) return\n    this.onStart(event, { cancel: () => this.onCancel(event) })\n  }\n\n  onPinchChange = (event: UseGestureEvent<TouchEvent>): void => {\n    const { canceled, active, time } = this.state\n    if (canceled || !active || event.touches.length !== 2 || event.timeStamp === time) return\n\n    this.onChange(event, { cancel: () => this.onCancel(event) })\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    return [['onTouchStart', this.onPinchStart], ['onTouchMove', this.onPinchChange], [['onTouchEnd', 'onTouchCancel'], this.onEnd]]\n  }\n}\n","import { WheelEvent } from 'react'\nimport DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport { getWheelEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { UseGestureEvent, ReactEventHandlerKey, Fn, Vector2 } from '../types'\n\nexport default class PinchWheelRecognizer extends DistanceAngleRecognizer {\n  sharedStartState = { pinching: true }\n  sharedEndState = { pinching: false }\n\n  constructor(controller: GestureController, args: any[]) {\n    super('pinch', controller, args)\n  }\n\n  getPayloadFromEvent(event: UseGestureEvent<WheelEvent>) {\n    const {\n      xy: [, delta_d],\n      ...sharedPayload\n    } = getWheelEventData(event)\n    const {\n      da: [prev_d, prev_a],\n    } = this.state\n    const d = prev_d - delta_d\n    const a = prev_a !== void 0 ? prev_a : 0\n    const origin: Vector2 = [event.clientX, event.clientY]\n    return { values: [d, a] as Vector2, gesturePayload: { origin }, sharedPayload }\n  }\n\n  onWheel = (event: UseGestureEvent<WheelEvent>): void => {\n    if (!event.ctrlKey) return\n\n    if (!this.controller.config.passiveEvents) event.preventDefault()\n    else if (process.env.NODE_ENV === 'development')\n      console.warn(\n        'To support zoom on trackpads, try using the `domTarget` option and `config.event.passive` set to `false`. This message will only appear in development mode.'\n      )\n\n    this.timeoutHandler(event)\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    return [['onWheel', this.onWheel]]\n  }\n}\n","import { TouchEvent } from 'react'\nimport DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport { getTwoTouchesEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { UseGestureEvent, ReactEventHandlerKey, WebKitGestureEvent, Fn, Vector2 } from '../types'\n\nconst SCALE_FACTOR = 260\n\nexport default class PinchWebKitGestureRecognizer extends DistanceAngleRecognizer {\n  sharedStartState = { pinching: true, down: true, touches: 2 }\n  sharedEndState = { pinching: false, down: false, touches: 0 }\n  private origin?: Vector2\n\n  constructor(controller: GestureController, args: any[]) {\n    super('pinch', controller, args)\n  }\n\n  getPayloadFromEvent(event: UseGestureEvent<WebKitGestureEvent>) {\n    return { values: [event.scale * SCALE_FACTOR, event.rotation] as Vector2 }\n  }\n\n  onPinchStart = (event: WebKitGestureEvent): void => {\n    if (!this.enabled) return\n    event.preventDefault()\n    const origin: Vector2 = this.origin ? this.origin : [event.clientX, event.clientY]\n\n    this.onStart(event, { origin, cancel: () => this.onCancel(event) })\n  }\n\n  onPinchChange = (event: WebKitGestureEvent): void => {\n    const { canceled, active } = this.state\n    if (canceled || !active) return\n    event.preventDefault()\n\n    this.onChange(event, { cancel: () => this.onCancel(event) })\n  }\n\n  onGestureEnd = (event: WebKitGestureEvent): void => {\n    this.onEnd(event)\n    event.preventDefault()\n    this.origin = undefined\n  }\n\n  updateTouchData = (event: UseGestureEvent<TouchEvent>): void => {\n    if (!this.enabled || event.touches.length !== 2) return\n    const { origin } = getTwoTouchesEventData(event)\n    this.origin = origin\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    return [\n      ['onGestureStart', this.onPinchStart],\n      ['onGestureChange', this.onPinchChange],\n      [['onGestureEnd', 'onTouchCancel'], this.onGestureEnd],\n      [['onTouchStart', 'onTouchMove'], this.updateTouchData],\n    ]\n  }\n}\n","import {\n  StateKey,\n  StateObject,\n  GestureState,\n  SharedGestureState,\n  GestureKey,\n  Fn,\n  ReactEventHandlerKey,\n  GestureFlag,\n  ReactEventHandlers,\n  GestureConfig,\n  GestureHandlers,\n  HandlerKey,\n  GestureHandlersPartial,\n} from '../types'\n\nimport { initialState, mappedKeys } from '../defaults'\nimport { addListeners, removeListeners, gestureEventSupported, chainFns } from '../utils'\n\nimport DragRecognizer from '../recognizers/DragRecognizer'\nimport ScrollRecognizer from '../recognizers/ScrollRecognizer'\nimport WheelRecognizer from '../recognizers/WheelRecognizer'\nimport MoveRecognizer from '../recognizers/MoveRecognizer'\nimport HoverRecognizer from '../recognizers/HoverRecognizer'\nimport PinchRecognizer from '../recognizers/PinchRecognizer'\nimport PinchWheelRecognizer from '../recognizers/PinchWheelRecognizer'\nimport PinchWebKitGestureRecognizer from '../recognizers/PinchWebKitGestureRecognizer'\nimport Recognizer from 'recognizers/Recognizer'\n\ntype GestureTimeouts = Partial<{ [stateKey in StateKey]: number }>\ntype WindowListeners = Partial<{ [stateKey in StateKey]: [string, Fn][] }>\ntype Bindings = Partial<{ [eventName in ReactEventHandlerKey]: Fn[] | Fn }>\n\n/**\n * Gesture controller will create gesture recognizers (which handle the gesture logic)\n * and keep track of the state for all gestures\n *\n * @template BinderType the type the bind function should return\n */\nexport default class GestureController {\n  public state: StateObject = initialState // state for all gestures\n  public timeouts: GestureTimeouts = {} // keeping track of timeouts for debounced gestures (such as move, scroll, wheel)\n  public actions: Set<HandlerKey>\n  private bindings: Bindings = {} // an object holding the handlers associated to the gestures\n  private domListeners: [string, Fn][] = [] // when config.domTarget is set, we attach events directly to the dom\n  private windowListeners: WindowListeners = {} // keeps track of window listeners added by gestures (drag only at the moment)\n  constructor(public handlers: GestureHandlersPartial, public config: GestureConfig) {\n    // if handlers contains {onDragStart, onDrag, onDragEnd, onMoveStart, onMove}\n    // actions will include 'onDrag' and 'onMove'\n    this.actions = new Set(Object.keys(this.handlers).map(k => <HandlerKey>k.replace(/End|Start/, '')))\n  }\n\n  /**\n   * Function run on component unmount\n   * Cleans timeouts and removes dom listeners set by the bind function\n   */\n  public clean = (): void => {\n    this.cleanOnBind()\n    Object.values(this.timeouts).forEach(clearTimeout)\n    Object.keys(this.windowListeners).forEach(stateKey => this.removeWindowListeners(<StateKey>stateKey))\n  }\n\n  /**\n   * Function run every time the bind function is run (ie on every render)\n   * Reset the binding object and remove dom listeners attached to config.domTarget\n   */\n  private cleanOnBind = (): void => {\n    this.bindings = {}\n    const { domTarget } = this.config\n    if (domTarget) {\n      removeListeners(<EventTarget>domTarget, this.domListeners, this.config.event)\n      this.domListeners = []\n    }\n  }\n\n  /**\n   * Commodity function to let gesture recognizer update global state\n   * @param sharedState shared partial state object\n   * @param gestureState partial gesture specific state object\n   * @param stateKey the state key ('drag', 'move'...)\n   */\n  public updateState = (sharedState: Partial<SharedGestureState> | null, gestureState: Partial<GestureState>, stateKey: StateKey): void => {\n    const newGestureState = { ...this.state[stateKey], ...gestureState }\n\n    if ('da' in newGestureState) newGestureState.da = newGestureState.values\n    else if ('xy' in newGestureState) newGestureState.xy = newGestureState.values\n\n    this.state = {\n      ...this.state,\n      shared: { ...this.state.shared, ...sharedState },\n      [stateKey]: newGestureState,\n    }\n  }\n\n  // fire the gesture handler defined by the user\n  public fireGestureHandler = (gestureKey: GestureKey, gestureFlag: GestureFlag): void => {\n    // gets the state key and handler key from the gesture key\n    // gestureKey: 'hover' -> stateKey: 'move', handlerKey: 'onHover'\n    const { stateKey, handlerKey } = mappedKeys[gestureKey]\n    const state = { ...this.state.shared, ...this.state[stateKey] }\n    if (state.event) state.event.gesture = gestureKey\n\n    if (gestureFlag === GestureFlag.OnStart) {\n      const handlerStart = `${handlerKey}Start` as keyof GestureHandlers\n      const handler = this.handlers[handlerStart] as any\n      handler && handler(state)\n    }\n\n    // whenever a flag is set, we run the default on[Gesture] function\n    // i.e. GestureFlag.OnStart would trigger both onDragStart and onDrag\n    const handler = this.handlers[handlerKey] as any\n    if (handler) {\n      const newMemo = handler(state)\n      this.state[stateKey].memo = newMemo !== void 0 ? newMemo : this.state[stateKey].memo\n    }\n\n    if (gestureFlag === GestureFlag.OnEnd) {\n      const handlerEnd = `${handlerKey}End` as keyof GestureHandlers\n      const handler = this.handlers[handlerEnd] as any\n      handler && handler(state)\n    }\n  }\n\n  /**\n   * Commodity function to let recognizers simply add listeners to config.window\n   * @param stateKey\n   * @param listeners\n   */\n  public addWindowListeners = (stateKey: StateKey, listeners: [string, Fn][]): void => {\n    if (!this.config.window) return\n    // we use this.windowListeners to keep track of the listeners we add\n    this.windowListeners[stateKey] = listeners\n    addListeners(this.config.window, listeners, this.config.event)\n  }\n\n  // commodity function to let recognizers simply remove listeners from config.window\n  public removeWindowListeners = (stateKey: StateKey): void => {\n    if (!this.config.window) return\n    const listeners = this.windowListeners[stateKey]\n    if (listeners) {\n      removeListeners(this.config.window, listeners, this.config.event)\n      delete this.windowListeners[stateKey]\n    }\n  }\n\n  /**\n   * Adds a recognizer to this.bindings\n   * @param recognizer\n   */\n  private addRecognizer = (recognizer: Recognizer): void => {\n    recognizer.getEventBindings().map(this.addEventBindings)\n  }\n\n  /**\n   * this.bindings is an object which keys match ReactEventHandlerKeys (onMouseMove, onTouchStart...).\n   * Since a recognizer might want to bind a handler function to an event key already used by a previously\n   * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\n   * that key.\n   */\n  private addEventBindings = ([eventNames, fn]: [ReactEventHandlerKey | ReactEventHandlerKey[], Fn]): void => {\n    const eventNamesArray = !Array.isArray(eventNames) ? [eventNames] : eventNames\n\n    eventNamesArray.forEach(eventName => {\n      this.bindings[eventName] = this.bindings[eventName] ? [...(<Fn[]>this.bindings[eventName]), fn] : [fn]\n    })\n  }\n\n  /**\n   * When config.domTarget is set, this function will add dom listeners to it\n   */\n  private addDomTargetListeners = (): void => {\n    const { domTarget } = this.config\n\n    // we iterate on the entries of this.binding\n    // for each event, we chain the array of functions mapped to it\n    // and push it to this.domListeners\n    Object.entries(this.bindings).forEach(([event, fns]) => {\n      this.domListeners.push([event.substr(2).toLowerCase(), chainFns(...(<Fn[]>fns))])\n    })\n\n    addListeners(<EventTarget>domTarget, this.domListeners, this.config.event)\n  }\n\n  /**\n   * getBindings will return an object that will be bound by users\n   * to the react component they want to interact with\n   */\n  private getBindings = (): ReactEventHandlers => {\n    const output: ReactEventHandlers = {}\n    const captureString = this.config.event.capture ? 'Capture' : ''\n\n    Object.entries(this.bindings).forEach(([event, fns]) => {\n      const fnsArray = Array.isArray(fns) ? fns : [fns]\n      const key = (event + captureString) as ReactEventHandlerKey\n      output[key] = chainFns(...(<Fn[]>fnsArray))\n    })\n\n    return output\n  }\n\n  public bind = (...args: any[]): Fn | ReactEventHandlers => {\n    const { domTarget } = this.config\n\n    const genuineHandlers = { ...this.handlers }\n\n    // cleaning before adding\n    this.cleanOnBind()\n\n    if (this.actions.has('onDrag')) {\n      this.addRecognizer(new DragRecognizer(this, args))\n      delete genuineHandlers.onDrag\n      delete genuineHandlers.onDragStart\n      delete genuineHandlers.onDragEnd\n    }\n    if (this.actions.has('onScroll')) {\n      this.addRecognizer(new ScrollRecognizer(this, args))\n      delete genuineHandlers.onScroll\n      delete genuineHandlers.onScrollStart\n      delete genuineHandlers.onScrollEnd\n    }\n    if (this.actions.has('onWheel')) {\n      this.addRecognizer(new WheelRecognizer(this, args))\n      delete genuineHandlers.onWheel\n      delete genuineHandlers.onWheelStart\n      delete genuineHandlers.onWheelEnd\n    }\n    if (this.actions.has('onMove')) {\n      this.addRecognizer(new MoveRecognizer(this, args))\n      delete genuineHandlers.onMove\n      delete genuineHandlers.onMoveStart\n      delete genuineHandlers.onMoveEnd\n    }\n    if (this.actions.has('onHover')) {\n      this.addRecognizer(new HoverRecognizer(this, args))\n      delete genuineHandlers.onHover\n    }\n    if (this.actions.has('onPinch')) {\n      // since react doesn't have handlers for gesture events we can only use them\n      // domTarget is set (and when the browser supprots them).\n      if (domTarget && gestureEventSupported()) {\n        this.addRecognizer(new PinchWebKitGestureRecognizer(this, args))\n      } else {\n        this.addRecognizer(new PinchRecognizer(this, args))\n        this.addRecognizer(new PinchWheelRecognizer(this, args))\n      }\n      delete genuineHandlers.onPinch\n      delete genuineHandlers.onPinchStart\n      delete genuineHandlers.onPinchEnd\n    }\n\n    // we also add event bindings for genuine handlers\n    Object.entries(genuineHandlers).map(([event, fn]) => {\n      // we're cheating when it comes to event type :(\n      this.addEventBindings([<ReactEventHandlerKey>event, <Fn>fn])\n    })\n\n    // if config.domTarget is set we add event listeners to it and return the clean function\n    if (domTarget) {\n      this.addDomTargetListeners()\n      return this.clean\n    }\n\n    // if not, we return an object that contains gesture handlers mapped to react handler event keys\n    return this.getBindings()\n  }\n}\n","import React from 'react'\nimport GestureController from './controllers/GestureController'\nimport { Handler, GestureHandlersPartial, GestureConfig, Coordinates, Fn, ReactEventHandlers, DistanceAngle, Omit } from './types'\nimport { defaultConfig } from './defaults'\n\n/** API\n * const bind = useDrag(() => { ... })\n * const bind = usePinch(() => { ... })\n * const bind = useMove(() => { ... })\n * const bind = useScroll(() => { ... })\n * const bind = useWheel(() => { ... })\n *\n * Handlers object:\n * const bind = useGesture({ onDrag: () => { ... }, onMove: () => { ... } })\n *\n * DomTarget:\n * const bind = useGesture({ onScroll: () => { ... } }, { domTarget: window })\n * React.useEffect(bind, [bind])\n */\n\ntype PartialGestureConfig = Partial<Omit<GestureConfig, 'passiveEvents'>>\ntype GetBinderTypeFromDomTarget<T extends PartialGestureConfig> = T['domTarget'] extends object ? Fn : ReactEventHandlers\n\nexport function useGesture<Config extends PartialGestureConfig>(\n  handlers: GestureHandlersPartial,\n  config?: Config\n): (...args: any[]) => GetBinderTypeFromDomTarget<Config> {\n  // the gesture controller will keep track of all gesture states\n  const gestureController = React.useRef<GestureController>()\n\n  if (!gestureController.current) {\n    // we initialize the gesture controller once\n    gestureController.current = new GestureController(handlers, getDerivedConfig(config))\n  }\n\n  React.useEffect(() => {\n    // every time handlers or config change, we let the gesture controller compute\n    // them so that the gesture handlers functions are aware of the changes\n    gestureController.current!.config = getDerivedConfig(config)\n    gestureController.current!.handlers = handlers\n  }, [handlers, config])\n\n  // when the user component unmounts, we run our gesture controller clean function\n  React.useEffect(() => gestureController.current!.clean, [])\n\n  // we return the bind function of our controller, which returns an binding object or\n  // a cleaning function depending on whether config.domTarget is set\n  return gestureController.current.bind as (...args: any[]) => GetBinderTypeFromDomTarget<Config>\n}\n\n/* SHORTHAND HANDLERS */\nexport const useDrag = (handler: Handler<Coordinates>, config?: PartialGestureConfig) => useGesture({ onDrag: handler }, config)\nexport const useMove = (handler: Handler<Coordinates>, config?: PartialGestureConfig) => useGesture({ onMove: handler }, config)\nexport const useHover = (handler: Handler<Coordinates>, config?: PartialGestureConfig) => useGesture({ onHover: handler }, config)\nexport const useScroll = (handler: Handler<Coordinates>, config?: PartialGestureConfig) => useGesture({ onScroll: handler }, config)\nexport const useWheel = (handler: Handler<Coordinates>, config?: PartialGestureConfig) => useGesture({ onWheel: handler }, config)\nexport const usePinch = (handler: Handler<DistanceAngle>, config?: PartialGestureConfig) => useGesture({ onPinch: handler }, config)\n\nfunction getDerivedConfig(config?: Partial<GestureConfig>): GestureConfig {\n  const derivedConfig = { ...defaultConfig, ...config }\n  const { domTarget } = derivedConfig\n  const realDomTarget = domTarget && 'current' in domTarget ? domTarget.current : domTarget\n  derivedConfig.domTarget = realDomTarget\n\n  const passive = derivedConfig.event.passive !== void 0 ? derivedConfig.event.passive : true\n\n  // TODO make test to check if passive is correctly passed to config\n\n  // if there isn't a domtarget or if event.passive is true, then passiveEvents is true\n  derivedConfig.passiveEvents = !derivedConfig.domTarget || passive\n\n  return derivedConfig\n}\n"],"names":["GestureFlag","noop","chainFns","fns","args","forEach","fn","addV","v1","v2","map","v","i","subV","setListeners","add","el","listeners","options","action","addListeners","removeListeners","getModifierKeys","event","shiftKey","altKey","metaKey","ctrlKey","getWheelEventData","xy","deltaX","deltaY","getPointerEventData","touches","buttons","changedTouches","touchEvents","length","clientX","clientY","down","getTwoTouchesEventData","dx","dy","da","Math","hypot","atan2","PI","origin","calculateVelocity","delta","delta_t","len","calculateVelocities","Array","fill","calculateDistance","movement","calculateDirection","calculateAllKinematics","velocities","velocity","distance","direction","mappedKeys","drag","stateKey","handlerKey","pinch","move","scroll","wheel","hover","defaultConfig","domTarget","undefined","passive","capture","window","dragDelay","passiveEvents","pointerEvents","enabled","initialCommon","currentTarget","pointerId","values","offset","initial","previous","first","last","active","time","cancel","canceled","memo","initialCoordinates","vxvy","initialDistanceAngle","vdva","turns","initialState","shared","hovering","scrolling","wheeling","dragging","moving","pinching","genericEndState","Recognizer","gestureKey","controller","callback","ms","_this","timeouts","setTimeout","clearTimeout","addWindowListeners","removeWindowListeners","sharedState","gestureState","updateState","gestureFlag","fireGestureHandler","payload","getPayloadFromEvent","gesturePayload","sharedPayload","startState","timeStamp","state","prevValues","continuousGesture","Object","assign","sharedStartState","OnStart","kinematics","getKinematics","OnChange","sharedEndState","OnEnd","requestAnimationFrame","onEnd","onChange","onStart","this","config","CoordinatesRecognizer","DEFAULT_DRAG_DELAY","DragRecognizer","setPointerCapture","onDragChange","onDragEnd","persist","delayedEvent","startDrag","onCancel","releasePointerCapture","getEventBindings","onDragStart","ScrollRecognizer","scrollX","scrollLeft","scrollY","scrollTop","getScrollEventData","timeoutHandler","WheelRecognizer","actions","has","prevXY","onWheel","MoveRecognizer","HoverRecognizer","onPointerEnter","onPointerLeave","DistanceAngleRecognizer","_Recognizer","d","a","delta_d","delta_a","newTurns","abs","sign","PinchRecognizer","onPinchStart","onPinchChange","PinchWheelRecognizer","preventDefault","prev_a","PinchWebKitGestureRecognizer","scale","rotation","onGestureEnd","updateTouchData","GestureController","handlers","cleanOnBind","keys","windowListeners","bindings","domListeners","newGestureState","gesture","handler","newMemo","recognizer","addEventBindings","eventNames","isArray","eventName","entries","push","substr","toLowerCase","output","captureString","fnsArray","genuineHandlers","addRecognizer","onDrag","onScroll","onScrollStart","onScrollEnd","onWheelStart","onWheelEnd","onMove","onMoveStart","onMoveEnd","onHover","GestureEvent","e","gestureEventSupported","onPinch","onPinchEnd","addDomTargetListeners","clean","getBindings","Set","k","replace","useGesture","gestureController","React","useRef","current","getDerivedConfig","useEffect","bind","derivedConfig"],"mappings":"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"}