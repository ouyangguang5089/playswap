{"ast":null,"code":"import _classCallCheck from\"/projects/testswap/uniswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _inherits from\"/projects/testswap/uniswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";import _createSuper from\"/projects/testswap/uniswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";import{AddressZero}from'@ethersproject/constants';import{ETHER,JSBI,Pair,Route,Token,TokenAmount,Trade,TradeType,WETH}from'@uniswap/sdk';import{useMemo}from'react';import{useActiveWeb3React}from'../hooks';import{useAllTokens}from'../hooks/Tokens';import{useV1FactoryContract}from'../hooks/useContract';import{Version}from'../hooks/useToggledVersion';import{NEVER_RELOAD,useSingleCallResult,useSingleContractMultipleData}from'../state/multicall/hooks';import{useETHBalances,useTokenBalance,useTokenBalances}from'../state/wallet/hooks';export function useV1ExchangeAddress(tokenAddress){var _useSingleCallResult,_useSingleCallResult$;var contract=useV1FactoryContract();var inputs=useMemo(function(){return[tokenAddress];},[tokenAddress]);return(_useSingleCallResult=useSingleCallResult(contract,'getExchange',inputs))===null||_useSingleCallResult===void 0?void 0:(_useSingleCallResult$=_useSingleCallResult.result)===null||_useSingleCallResult$===void 0?void 0:_useSingleCallResult$[0];}export var MockV1Pair=/*#__PURE__*/function(_Pair){_inherits(MockV1Pair,_Pair);var _super=_createSuper(MockV1Pair);function MockV1Pair(etherAmount,tokenAmount){_classCallCheck(this,MockV1Pair);return _super.call(this,tokenAmount,new TokenAmount(WETH[tokenAmount.token.chainId],etherAmount));}return MockV1Pair;}(Pair);function useMockV1Pair(inputCurrency){var token=inputCurrency instanceof Token?inputCurrency:undefined;var isWETH=Boolean(token&&token.equals(WETH[token.chainId]));var v1PairAddress=useV1ExchangeAddress(isWETH?undefined:token===null||token===void 0?void 0:token.address);var tokenBalance=useTokenBalance(v1PairAddress,token);var ETHBalance=useETHBalances([v1PairAddress])[v1PairAddress!==null&&v1PairAddress!==void 0?v1PairAddress:''];return useMemo(function(){return token&&tokenBalance&&ETHBalance&&inputCurrency?new MockV1Pair(ETHBalance.raw,tokenBalance):undefined;},[ETHBalance,inputCurrency,token,tokenBalance]);}// returns all v1 exchange addresses in the user's token list\nexport function useAllTokenV1Exchanges(){var allTokens=useAllTokens();var factory=useV1FactoryContract();var args=useMemo(function(){return Object.keys(allTokens).map(function(tokenAddress){return[tokenAddress];});},[allTokens]);var data=useSingleContractMultipleData(factory,'getExchange',args,NEVER_RELOAD);return useMemo(function(){var _data$reduce;return(_data$reduce=data===null||data===void 0?void 0:data.reduce(function(memo,_ref,ix){var result=_ref.result;if((result===null||result===void 0?void 0:result[0])&&result[0]!==AddressZero){memo[result[0]]=allTokens[args[ix][0]];}return memo;},{}))!==null&&_data$reduce!==void 0?_data$reduce:{};},[allTokens,args,data]);}// returns whether any of the tokens in the user's token list have liquidity on v1\nexport function useUserHasLiquidityInAllTokens(){var _useActiveWeb3React=useActiveWeb3React(),account=_useActiveWeb3React.account,chainId=_useActiveWeb3React.chainId;var exchanges=useAllTokenV1Exchanges();var v1ExchangeLiquidityTokens=useMemo(function(){return chainId?Object.keys(exchanges).map(function(address){return new Token(chainId,address,18,'UNI-V1','Uniswap V1');}):[];},[chainId,exchanges]);var balances=useTokenBalances(account!==null&&account!==void 0?account:undefined,v1ExchangeLiquidityTokens);return useMemo(function(){return Object.keys(balances).some(function(tokenAddress){var _balances$tokenAddres;var b=(_balances$tokenAddres=balances[tokenAddress])===null||_balances$tokenAddres===void 0?void 0:_balances$tokenAddres.raw;return b&&JSBI.greaterThan(b,JSBI.BigInt(0));});},[balances]);}/**\n * Returns the trade to execute on V1 to go between input and output token\n */export function useV1Trade(isExactIn,inputCurrency,outputCurrency,exactAmount){// get the mock v1 pairs\nvar inputPair=useMockV1Pair(inputCurrency);var outputPair=useMockV1Pair(outputCurrency);var inputIsETH=inputCurrency===ETHER;var outputIsETH=outputCurrency===ETHER;// construct a direct or through ETH v1 route\nvar pairs=[];if(inputIsETH&&outputPair){pairs=[outputPair];}else if(outputIsETH&&inputPair){pairs=[inputPair];}// if neither are ETH, it's token-to-token (if they both exist)\nelse if(inputPair&&outputPair){pairs=[inputPair,outputPair];}var route=inputCurrency&&pairs&&pairs.length>0&&new Route(pairs,inputCurrency,outputCurrency);var v1Trade;try{v1Trade=route&&exactAmount?new Trade(route,exactAmount,isExactIn?TradeType.EXACT_INPUT:TradeType.EXACT_OUTPUT):undefined;}catch(error){console.debug('Failed to create V1 trade',error);}return v1Trade;}export function getTradeVersion(trade){var _trade$route,_trade$route$pairs;var isV1=trade===null||trade===void 0?void 0:(_trade$route=trade.route)===null||_trade$route===void 0?void 0:(_trade$route$pairs=_trade$route.pairs)===null||_trade$route$pairs===void 0?void 0:_trade$route$pairs.some(function(pair){return pair instanceof MockV1Pair;});if(isV1)return Version.v1;if(isV1===false)return Version.v2;return undefined;}// returns the v1 exchange against which a trade should be executed\nexport function useV1TradeExchangeAddress(trade){var tokenAddress=useMemo(function(){if(!trade)return undefined;var isV1=getTradeVersion(trade)===Version.v1;if(!isV1)return undefined;return trade.inputAmount instanceof TokenAmount?trade.inputAmount.token.address:trade.outputAmount instanceof TokenAmount?trade.outputAmount.token.address:undefined;},[trade]);return useV1ExchangeAddress(tokenAddress);}","map":{"version":3,"sources":["/projects/testswap/uniswap-interface/src/data/V1.ts"],"names":["AddressZero","ETHER","JSBI","Pair","Route","Token","TokenAmount","Trade","TradeType","WETH","useMemo","useActiveWeb3React","useAllTokens","useV1FactoryContract","Version","NEVER_RELOAD","useSingleCallResult","useSingleContractMultipleData","useETHBalances","useTokenBalance","useTokenBalances","useV1ExchangeAddress","tokenAddress","contract","inputs","result","MockV1Pair","etherAmount","tokenAmount","token","chainId","useMockV1Pair","inputCurrency","undefined","isWETH","Boolean","equals","v1PairAddress","address","tokenBalance","ETHBalance","raw","useAllTokenV1Exchanges","allTokens","factory","args","Object","keys","map","data","reduce","memo","ix","useUserHasLiquidityInAllTokens","account","exchanges","v1ExchangeLiquidityTokens","balances","some","b","greaterThan","BigInt","useV1Trade","isExactIn","outputCurrency","exactAmount","inputPair","outputPair","inputIsETH","outputIsETH","pairs","route","length","v1Trade","EXACT_INPUT","EXACT_OUTPUT","error","console","debug","getTradeVersion","trade","isV1","pair","v1","v2","useV1TradeExchangeAddress","inputAmount","outputAmount"],"mappings":"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","sourcesContent":["import { AddressZero } from '@ethersproject/constants'\nimport {\n  BigintIsh,\n  Currency,\n  CurrencyAmount,\n  ETHER,\n  JSBI,\n  Pair,\n  Route,\n  Token,\n  TokenAmount,\n  Trade,\n  TradeType,\n  WETH\n} from '@uniswap/sdk'\nimport { useMemo } from 'react'\nimport { useActiveWeb3React } from '../hooks'\nimport { useAllTokens } from '../hooks/Tokens'\nimport { useV1FactoryContract } from '../hooks/useContract'\nimport { Version } from '../hooks/useToggledVersion'\nimport { NEVER_RELOAD, useSingleCallResult, useSingleContractMultipleData } from '../state/multicall/hooks'\nimport { useETHBalances, useTokenBalance, useTokenBalances } from '../state/wallet/hooks'\n\nexport function useV1ExchangeAddress(tokenAddress?: string): string | undefined {\n  const contract = useV1FactoryContract()\n\n  const inputs = useMemo(() => [tokenAddress], [tokenAddress])\n  return useSingleCallResult(contract, 'getExchange', inputs)?.result?.[0]\n}\n\nexport class MockV1Pair extends Pair {\n  constructor(etherAmount: BigintIsh, tokenAmount: TokenAmount) {\n    super(tokenAmount, new TokenAmount(WETH[tokenAmount.token.chainId], etherAmount))\n  }\n}\n\nfunction useMockV1Pair(inputCurrency?: Currency): MockV1Pair | undefined {\n  const token = inputCurrency instanceof Token ? inputCurrency : undefined\n\n  const isWETH = Boolean(token && token.equals(WETH[token.chainId]))\n  const v1PairAddress = useV1ExchangeAddress(isWETH ? undefined : token?.address)\n  const tokenBalance = useTokenBalance(v1PairAddress, token)\n  const ETHBalance = useETHBalances([v1PairAddress])[v1PairAddress ?? '']\n\n  return useMemo(\n    () =>\n      token && tokenBalance && ETHBalance && inputCurrency ? new MockV1Pair(ETHBalance.raw, tokenBalance) : undefined,\n    [ETHBalance, inputCurrency, token, tokenBalance]\n  )\n}\n\n// returns all v1 exchange addresses in the user's token list\nexport function useAllTokenV1Exchanges(): { [exchangeAddress: string]: Token } {\n  const allTokens = useAllTokens()\n  const factory = useV1FactoryContract()\n  const args = useMemo(() => Object.keys(allTokens).map(tokenAddress => [tokenAddress]), [allTokens])\n\n  const data = useSingleContractMultipleData(factory, 'getExchange', args, NEVER_RELOAD)\n\n  return useMemo(\n    () =>\n      data?.reduce<{ [exchangeAddress: string]: Token }>((memo, { result }, ix) => {\n        if (result?.[0] && result[0] !== AddressZero) {\n          memo[result[0]] = allTokens[args[ix][0]]\n        }\n        return memo\n      }, {}) ?? {},\n    [allTokens, args, data]\n  )\n}\n\n// returns whether any of the tokens in the user's token list have liquidity on v1\nexport function useUserHasLiquidityInAllTokens(): boolean | undefined {\n  const { account, chainId } = useActiveWeb3React()\n\n  const exchanges = useAllTokenV1Exchanges()\n\n  const v1ExchangeLiquidityTokens = useMemo(\n    () =>\n      chainId ? Object.keys(exchanges).map(address => new Token(chainId, address, 18, 'UNI-V1', 'Uniswap V1')) : [],\n    [chainId, exchanges]\n  )\n\n  const balances = useTokenBalances(account ?? undefined, v1ExchangeLiquidityTokens)\n\n  return useMemo(\n    () =>\n      Object.keys(balances).some(tokenAddress => {\n        const b = balances[tokenAddress]?.raw\n        return b && JSBI.greaterThan(b, JSBI.BigInt(0))\n      }),\n    [balances]\n  )\n}\n\n/**\n * Returns the trade to execute on V1 to go between input and output token\n */\nexport function useV1Trade(\n  isExactIn?: boolean,\n  inputCurrency?: Currency,\n  outputCurrency?: Currency,\n  exactAmount?: CurrencyAmount\n): Trade | undefined {\n  // get the mock v1 pairs\n  const inputPair = useMockV1Pair(inputCurrency)\n  const outputPair = useMockV1Pair(outputCurrency)\n\n  const inputIsETH = inputCurrency === ETHER\n  const outputIsETH = outputCurrency === ETHER\n\n  // construct a direct or through ETH v1 route\n  let pairs: Pair[] = []\n  if (inputIsETH && outputPair) {\n    pairs = [outputPair]\n  } else if (outputIsETH && inputPair) {\n    pairs = [inputPair]\n  }\n  // if neither are ETH, it's token-to-token (if they both exist)\n  else if (inputPair && outputPair) {\n    pairs = [inputPair, outputPair]\n  }\n\n  const route = inputCurrency && pairs && pairs.length > 0 && new Route(pairs, inputCurrency, outputCurrency)\n  let v1Trade: Trade | undefined\n  try {\n    v1Trade =\n      route && exactAmount\n        ? new Trade(route, exactAmount, isExactIn ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT)\n        : undefined\n  } catch (error) {\n    console.debug('Failed to create V1 trade', error)\n  }\n  return v1Trade\n}\n\nexport function getTradeVersion(trade?: Trade): Version | undefined {\n  const isV1 = trade?.route?.pairs?.some(pair => pair instanceof MockV1Pair)\n  if (isV1) return Version.v1\n  if (isV1 === false) return Version.v2\n  return undefined\n}\n\n// returns the v1 exchange against which a trade should be executed\nexport function useV1TradeExchangeAddress(trade: Trade | undefined): string | undefined {\n  const tokenAddress: string | undefined = useMemo(() => {\n    if (!trade) return undefined\n    const isV1 = getTradeVersion(trade) === Version.v1\n    if (!isV1) return undefined\n    return trade.inputAmount instanceof TokenAmount\n      ? trade.inputAmount.token.address\n      : trade.outputAmount instanceof TokenAmount\n      ? trade.outputAmount.token.address\n      : undefined\n  }, [trade])\n  return useV1ExchangeAddress(tokenAddress)\n}\n"]},"metadata":{},"sourceType":"module"}