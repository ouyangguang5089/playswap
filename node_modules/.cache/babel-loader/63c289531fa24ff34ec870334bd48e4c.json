{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/objectSpread\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport * as utils from './utils.js';\nimport baseLogger from './logger.js';\n\nvar Interpolator = /*#__PURE__*/function () {\n  function Interpolator() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Interpolator);\n\n    this.logger = baseLogger.create('interpolator');\n    this.init(options, true);\n  }\n  /* eslint no-param-reassign: 0 */\n\n\n  _createClass(Interpolator, [{\n    key: \"init\",\n    value: function init() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var reset = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (reset) {\n        this.options = options;\n\n        this.format = options.interpolation && options.interpolation.format || function (value) {\n          return value;\n        };\n      }\n\n      if (!options.interpolation) options.interpolation = {\n        escapeValue: true\n      };\n      var iOpts = options.interpolation;\n      this.escape = iOpts.escape !== undefined ? iOpts.escape : utils.escape;\n      this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;\n      this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;\n      this.prefix = iOpts.prefix ? utils.regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';\n      this.suffix = iOpts.suffix ? utils.regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';\n      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';\n      this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';\n      this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';\n      this.nestingPrefix = iOpts.nestingPrefix ? utils.regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || utils.regexEscape('$t(');\n      this.nestingSuffix = iOpts.nestingSuffix ? utils.regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || utils.regexEscape(')');\n      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000; // the regexp\n\n      this.resetRegExp();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this.options) this.init(this.options);\n    }\n  }, {\n    key: \"resetRegExp\",\n    value: function resetRegExp() {\n      // the regexp\n      var regexpStr = \"\".concat(this.prefix, \"(.+?)\").concat(this.suffix);\n      this.regexp = new RegExp(regexpStr, 'g');\n      var regexpUnescapeStr = \"\".concat(this.prefix).concat(this.unescapePrefix, \"(.+?)\").concat(this.unescapeSuffix).concat(this.suffix);\n      this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');\n      var nestingRegexpStr = \"\".concat(this.nestingPrefix, \"(.+?)\").concat(this.nestingSuffix);\n      this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');\n    }\n  }, {\n    key: \"interpolate\",\n    value: function interpolate(str, data, lng, options) {\n      var _this = this;\n\n      var match;\n      var value;\n      var replaces;\n\n      function regexSafe(val) {\n        return val.replace(/\\$/g, '$$$$');\n      }\n\n      var handleFormat = function handleFormat(key) {\n        if (key.indexOf(_this.formatSeparator) < 0) return utils.getPath(data, key);\n        var p = key.split(_this.formatSeparator);\n        var k = p.shift().trim();\n        var f = p.join(_this.formatSeparator).trim();\n        return _this.format(utils.getPath(data, k), f, lng);\n      };\n\n      this.resetRegExp();\n      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;\n      replaces = 0; // unescape if has unescapePrefix/Suffix\n\n      /* eslint no-cond-assign: 0 */\n\n      while (match = this.regexpUnescape.exec(str)) {\n        value = handleFormat(match[1].trim());\n        str = str.replace(match[0], value);\n        this.regexpUnescape.lastIndex = 0;\n        replaces++;\n\n        if (replaces >= this.maxReplaces) {\n          break;\n        }\n      }\n\n      replaces = 0; // regular escape on demand\n\n      while (match = this.regexp.exec(str)) {\n        value = handleFormat(match[1].trim());\n\n        if (value === undefined) {\n          if (typeof missingInterpolationHandler === 'function') {\n            var temp = missingInterpolationHandler(str, match, options);\n            value = typeof temp === 'string' ? temp : '';\n          } else {\n            this.logger.warn(\"missed to pass in variable \".concat(match[1], \" for interpolating \").concat(str));\n            value = '';\n          }\n        } else if (typeof value !== 'string' && !this.useRawValueToEscape) {\n          value = utils.makeString(value);\n        }\n\n        value = this.escapeValue ? regexSafe(this.escape(value)) : regexSafe(value);\n        str = str.replace(match[0], value);\n        this.regexp.lastIndex = 0;\n        replaces++;\n\n        if (replaces >= this.maxReplaces) {\n          break;\n        }\n      }\n\n      return str;\n    }\n  }, {\n    key: \"nest\",\n    value: function nest(str, fc) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var match;\n      var value;\n\n      var clonedOptions = _objectSpread({}, options);\n\n      clonedOptions.applyPostProcessor = false; // avoid post processing on nested lookup\n      // if value is something like \"myKey\": \"lorem $(anotherKey, { \"count\": {{aValueInOptions}} })\"\n\n      function handleHasOptions(key, inheritedOptions) {\n        if (key.indexOf(',') < 0) return key;\n        var p = key.split(',');\n        key = p.shift();\n        var optionsString = p.join(',');\n        optionsString = this.interpolate(optionsString, clonedOptions);\n        optionsString = optionsString.replace(/'/g, '\"');\n\n        try {\n          clonedOptions = JSON.parse(optionsString);\n          if (inheritedOptions) clonedOptions = _objectSpread({}, inheritedOptions, clonedOptions);\n        } catch (e) {\n          this.logger.error(\"failed parsing options string in nesting for key \".concat(key), e);\n        }\n\n        return key;\n      } // regular escape on demand\n\n\n      while (match = this.nestingRegexp.exec(str)) {\n        value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions); // is only the nesting key (key1 = '$(key2)') return the value without stringify\n\n        if (value && match[0] === str && typeof value !== 'string') return value; // no string to include or empty\n\n        if (typeof value !== 'string') value = utils.makeString(value);\n\n        if (!value) {\n          this.logger.warn(\"missed to resolve \".concat(match[1], \" for nesting \").concat(str));\n          value = '';\n        } // Nested keys should not be escaped by default #854\n        // value = this.escapeValue ? regexSafe(utils.escape(value)) : regexSafe(value);\n\n\n        str = str.replace(match[0], value);\n        this.regexp.lastIndex = 0;\n      }\n\n      return str;\n    }\n  }]);\n\n  return Interpolator;\n}();\n\nexport default Interpolator;","map":{"version":3,"sources":["/projects/testswap/uniswap-interface/node_modules/i18next/dist/es/Interpolator.js"],"names":["_objectSpread","_classCallCheck","_createClass","utils","baseLogger","Interpolator","options","arguments","length","undefined","logger","create","init","key","value","reset","format","interpolation","escapeValue","iOpts","escape","useRawValueToEscape","prefix","regexEscape","prefixEscaped","suffix","suffixEscaped","formatSeparator","unescapePrefix","unescapeSuffix","nestingPrefix","nestingPrefixEscaped","nestingSuffix","nestingSuffixEscaped","maxReplaces","resetRegExp","regexpStr","concat","regexp","RegExp","regexpUnescapeStr","regexpUnescape","nestingRegexpStr","nestingRegexp","interpolate","str","data","lng","_this","match","replaces","regexSafe","val","replace","handleFormat","indexOf","getPath","p","split","k","shift","trim","f","join","missingInterpolationHandler","exec","lastIndex","temp","warn","makeString","nest","fc","clonedOptions","applyPostProcessor","handleHasOptions","inheritedOptions","optionsString","JSON","parse","e","error","call"],"mappings":"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","sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/objectSpread\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport * as utils from './utils.js';\nimport baseLogger from './logger.js';\n\nvar Interpolator =\n/*#__PURE__*/\nfunction () {\n  function Interpolator() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Interpolator);\n\n    this.logger = baseLogger.create('interpolator');\n    this.init(options, true);\n  }\n  /* eslint no-param-reassign: 0 */\n\n\n  _createClass(Interpolator, [{\n    key: \"init\",\n    value: function init() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var reset = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (reset) {\n        this.options = options;\n\n        this.format = options.interpolation && options.interpolation.format || function (value) {\n          return value;\n        };\n      }\n\n      if (!options.interpolation) options.interpolation = {\n        escapeValue: true\n      };\n      var iOpts = options.interpolation;\n      this.escape = iOpts.escape !== undefined ? iOpts.escape : utils.escape;\n      this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;\n      this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;\n      this.prefix = iOpts.prefix ? utils.regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';\n      this.suffix = iOpts.suffix ? utils.regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';\n      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';\n      this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';\n      this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';\n      this.nestingPrefix = iOpts.nestingPrefix ? utils.regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || utils.regexEscape('$t(');\n      this.nestingSuffix = iOpts.nestingSuffix ? utils.regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || utils.regexEscape(')');\n      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000; // the regexp\n\n      this.resetRegExp();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this.options) this.init(this.options);\n    }\n  }, {\n    key: \"resetRegExp\",\n    value: function resetRegExp() {\n      // the regexp\n      var regexpStr = \"\".concat(this.prefix, \"(.+?)\").concat(this.suffix);\n      this.regexp = new RegExp(regexpStr, 'g');\n      var regexpUnescapeStr = \"\".concat(this.prefix).concat(this.unescapePrefix, \"(.+?)\").concat(this.unescapeSuffix).concat(this.suffix);\n      this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');\n      var nestingRegexpStr = \"\".concat(this.nestingPrefix, \"(.+?)\").concat(this.nestingSuffix);\n      this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');\n    }\n  }, {\n    key: \"interpolate\",\n    value: function interpolate(str, data, lng, options) {\n      var _this = this;\n\n      var match;\n      var value;\n      var replaces;\n\n      function regexSafe(val) {\n        return val.replace(/\\$/g, '$$$$');\n      }\n\n      var handleFormat = function handleFormat(key) {\n        if (key.indexOf(_this.formatSeparator) < 0) return utils.getPath(data, key);\n        var p = key.split(_this.formatSeparator);\n        var k = p.shift().trim();\n        var f = p.join(_this.formatSeparator).trim();\n        return _this.format(utils.getPath(data, k), f, lng);\n      };\n\n      this.resetRegExp();\n      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;\n      replaces = 0; // unescape if has unescapePrefix/Suffix\n\n      /* eslint no-cond-assign: 0 */\n\n      while (match = this.regexpUnescape.exec(str)) {\n        value = handleFormat(match[1].trim());\n        str = str.replace(match[0], value);\n        this.regexpUnescape.lastIndex = 0;\n        replaces++;\n\n        if (replaces >= this.maxReplaces) {\n          break;\n        }\n      }\n\n      replaces = 0; // regular escape on demand\n\n      while (match = this.regexp.exec(str)) {\n        value = handleFormat(match[1].trim());\n\n        if (value === undefined) {\n          if (typeof missingInterpolationHandler === 'function') {\n            var temp = missingInterpolationHandler(str, match, options);\n            value = typeof temp === 'string' ? temp : '';\n          } else {\n            this.logger.warn(\"missed to pass in variable \".concat(match[1], \" for interpolating \").concat(str));\n            value = '';\n          }\n        } else if (typeof value !== 'string' && !this.useRawValueToEscape) {\n          value = utils.makeString(value);\n        }\n\n        value = this.escapeValue ? regexSafe(this.escape(value)) : regexSafe(value);\n        str = str.replace(match[0], value);\n        this.regexp.lastIndex = 0;\n        replaces++;\n\n        if (replaces >= this.maxReplaces) {\n          break;\n        }\n      }\n\n      return str;\n    }\n  }, {\n    key: \"nest\",\n    value: function nest(str, fc) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var match;\n      var value;\n\n      var clonedOptions = _objectSpread({}, options);\n\n      clonedOptions.applyPostProcessor = false; // avoid post processing on nested lookup\n      // if value is something like \"myKey\": \"lorem $(anotherKey, { \"count\": {{aValueInOptions}} })\"\n\n      function handleHasOptions(key, inheritedOptions) {\n        if (key.indexOf(',') < 0) return key;\n        var p = key.split(',');\n        key = p.shift();\n        var optionsString = p.join(',');\n        optionsString = this.interpolate(optionsString, clonedOptions);\n        optionsString = optionsString.replace(/'/g, '\"');\n\n        try {\n          clonedOptions = JSON.parse(optionsString);\n          if (inheritedOptions) clonedOptions = _objectSpread({}, inheritedOptions, clonedOptions);\n        } catch (e) {\n          this.logger.error(\"failed parsing options string in nesting for key \".concat(key), e);\n        }\n\n        return key;\n      } // regular escape on demand\n\n\n      while (match = this.nestingRegexp.exec(str)) {\n        value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions); // is only the nesting key (key1 = '$(key2)') return the value without stringify\n\n        if (value && match[0] === str && typeof value !== 'string') return value; // no string to include or empty\n\n        if (typeof value !== 'string') value = utils.makeString(value);\n\n        if (!value) {\n          this.logger.warn(\"missed to resolve \".concat(match[1], \" for nesting \").concat(str));\n          value = '';\n        } // Nested keys should not be escaped by default #854\n        // value = this.escapeValue ? regexSafe(utils.escape(value)) : regexSafe(value);\n\n\n        str = str.replace(match[0], value);\n        this.regexp.lastIndex = 0;\n      }\n\n      return str;\n    }\n  }]);\n\n  return Interpolator;\n}();\n\nexport default Interpolator;"]},"metadata":{},"sourceType":"module"}