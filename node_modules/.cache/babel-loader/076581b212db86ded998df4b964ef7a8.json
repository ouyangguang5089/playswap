{"ast":null,"code":"import _regeneratorRuntime from\"/projects/testswap/uniswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/projects/testswap/uniswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{Contract}from'@ethersproject/contracts';import{namehash}from'ethers/lib/utils';var REGISTRAR_ABI=[{constant:true,inputs:[{name:'node',type:'bytes32'}],name:'resolver',outputs:[{name:'resolverAddress',type:'address'}],payable:false,stateMutability:'view',type:'function'}];var REGISTRAR_ADDRESS='0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e';var RESOLVER_ABI=[{constant:true,inputs:[{internalType:'bytes32',name:'node',type:'bytes32'}],name:'contenthash',outputs:[{internalType:'bytes',name:'',type:'bytes'}],payable:false,stateMutability:'view',type:'function'}];// cache the resolver contracts since most of them are the public resolver\nfunction resolverContract(resolverAddress,provider){return new Contract(resolverAddress,RESOLVER_ABI,provider);}/**\n * Fetches and decodes the result of an ENS contenthash lookup on mainnet to a URI\n * @param ensName to resolve\n * @param provider provider to use to fetch the data\n */export default function resolveENSContentHash(_x,_x2){return _resolveENSContentHash.apply(this,arguments);}function _resolveENSContentHash(){_resolveENSContentHash=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(ensName,provider){var ensRegistrarContract,hash,resolverAddress;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:ensRegistrarContract=new Contract(REGISTRAR_ADDRESS,REGISTRAR_ABI,provider);hash=namehash(ensName);_context.next=4;return ensRegistrarContract.resolver(hash);case 4:resolverAddress=_context.sent;return _context.abrupt(\"return\",resolverContract(resolverAddress,provider).contenthash(hash));case 6:case\"end\":return _context.stop();}}},_callee);}));return _resolveENSContentHash.apply(this,arguments);}","map":{"version":3,"sources":["/projects/testswap/uniswap-interface/src/utils/resolveENSContentHash.ts"],"names":["Contract","namehash","REGISTRAR_ABI","constant","inputs","name","type","outputs","payable","stateMutability","REGISTRAR_ADDRESS","RESOLVER_ABI","internalType","resolverContract","resolverAddress","provider","resolveENSContentHash","ensName","ensRegistrarContract","hash","resolver","contenthash"],"mappings":"mTAAA,OAASA,QAAT,KAAyB,0BAAzB,CAEA,OAASC,QAAT,KAAyB,kBAAzB,CAEA,GAAMC,CAAAA,aAAa,CAAG,CACpB,CACEC,QAAQ,CAAE,IADZ,CAEEC,MAAM,CAAE,CACN,CACEC,IAAI,CAAE,MADR,CAEEC,IAAI,CAAE,SAFR,CADM,CAFV,CAQED,IAAI,CAAE,UARR,CASEE,OAAO,CAAE,CACP,CACEF,IAAI,CAAE,iBADR,CAEEC,IAAI,CAAE,SAFR,CADO,CATX,CAeEE,OAAO,CAAE,KAfX,CAgBEC,eAAe,CAAE,MAhBnB,CAiBEH,IAAI,CAAE,UAjBR,CADoB,CAAtB,CAqBA,GAAMI,CAAAA,iBAAiB,CAAG,4CAA1B,CAEA,GAAMC,CAAAA,YAAY,CAAG,CACnB,CACER,QAAQ,CAAE,IADZ,CAEEC,MAAM,CAAE,CACN,CACEQ,YAAY,CAAE,SADhB,CAEEP,IAAI,CAAE,MAFR,CAGEC,IAAI,CAAE,SAHR,CADM,CAFV,CASED,IAAI,CAAE,aATR,CAUEE,OAAO,CAAE,CACP,CACEK,YAAY,CAAE,OADhB,CAEEP,IAAI,CAAE,EAFR,CAGEC,IAAI,CAAE,OAHR,CADO,CAVX,CAiBEE,OAAO,CAAE,KAjBX,CAkBEC,eAAe,CAAE,MAlBnB,CAmBEH,IAAI,CAAE,UAnBR,CADmB,CAArB,CAwBA;AACA,QAASO,CAAAA,gBAAT,CAA0BC,eAA1B,CAAmDC,QAAnD,CAAiF,CAC/E,MAAO,IAAIf,CAAAA,QAAJ,CAAac,eAAb,CAA8BH,YAA9B,CAA4CI,QAA5C,CAAP,CACD,CAED;;;;GAKA,uBAA8BC,CAAAA,qBAA9B,8D,iHAAe,iBAAqCC,OAArC,CAAsDF,QAAtD,gKACPG,oBADO,CACgB,GAAIlB,CAAAA,QAAJ,CAAaU,iBAAb,CAAgCR,aAAhC,CAA+Ca,QAA/C,CADhB,CAEPI,IAFO,CAEAlB,QAAQ,CAACgB,OAAD,CAFR,uBAGiBC,CAAAA,oBAAoB,CAACE,QAArB,CAA8BD,IAA9B,CAHjB,QAGPL,eAHO,+CAIND,gBAAgB,CAACC,eAAD,CAAkBC,QAAlB,CAAhB,CAA4CM,WAA5C,CAAwDF,IAAxD,CAJM,wD","sourcesContent":["import { Contract } from '@ethersproject/contracts'\nimport { Provider } from '@ethersproject/abstract-provider'\nimport { namehash } from 'ethers/lib/utils'\n\nconst REGISTRAR_ABI = [\n  {\n    constant: true,\n    inputs: [\n      {\n        name: 'node',\n        type: 'bytes32'\n      }\n    ],\n    name: 'resolver',\n    outputs: [\n      {\n        name: 'resolverAddress',\n        type: 'address'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  }\n]\nconst REGISTRAR_ADDRESS = '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'\n\nconst RESOLVER_ABI = [\n  {\n    constant: true,\n    inputs: [\n      {\n        internalType: 'bytes32',\n        name: 'node',\n        type: 'bytes32'\n      }\n    ],\n    name: 'contenthash',\n    outputs: [\n      {\n        internalType: 'bytes',\n        name: '',\n        type: 'bytes'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  }\n]\n\n// cache the resolver contracts since most of them are the public resolver\nfunction resolverContract(resolverAddress: string, provider: Provider): Contract {\n  return new Contract(resolverAddress, RESOLVER_ABI, provider)\n}\n\n/**\n * Fetches and decodes the result of an ENS contenthash lookup on mainnet to a URI\n * @param ensName to resolve\n * @param provider provider to use to fetch the data\n */\nexport default async function resolveENSContentHash(ensName: string, provider: Provider): Promise<string> {\n  const ensRegistrarContract = new Contract(REGISTRAR_ADDRESS, REGISTRAR_ABI, provider)\n  const hash = namehash(ensName)\n  const resolverAddress = await ensRegistrarContract.resolver(hash)\n  return resolverContract(resolverAddress, provider).contenthash(hash)\n}\n"]},"metadata":{},"sourceType":"module"}