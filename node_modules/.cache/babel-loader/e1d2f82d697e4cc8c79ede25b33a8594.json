{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar color_1 = require(\"../color\");\n\nvar vbox_1 = __importDefault(require(\"./vbox\"));\n\nvar pqueue_1 = __importDefault(require(\"./pqueue\"));\n\nvar fractByPopulations = 0.75;\n\nfunction _splitBoxes(pq, target) {\n  var lastSize = pq.size();\n\n  while (pq.size() < target) {\n    var vbox = pq.pop();\n\n    if (vbox && vbox.count() > 0) {\n      var _a = vbox.split(),\n          vbox1 = _a[0],\n          vbox2 = _a[1];\n\n      pq.push(vbox1);\n      if (vbox2 && vbox2.count() > 0) pq.push(vbox2); // No more new boxes, converged\n\n      if (pq.size() === lastSize) {\n        break;\n      } else {\n        lastSize = pq.size();\n      }\n    } else {\n      break;\n    }\n  }\n}\n\nvar MMCQ = function MMCQ(pixels, opts) {\n  if (pixels.length === 0 || opts.colorCount < 2 || opts.colorCount > 256) {\n    throw new Error('Wrong MMCQ parameters');\n  }\n\n  var vbox = vbox_1.default.build(pixels);\n  var hist = vbox.hist;\n  var colorCount = Object.keys(hist).length;\n  var pq = new pqueue_1.default(function (a, b) {\n    return a.count() - b.count();\n  });\n  pq.push(vbox); // first set of colors, sorted by population\n\n  _splitBoxes(pq, fractByPopulations * opts.colorCount); // Re-order\n\n\n  var pq2 = new pqueue_1.default(function (a, b) {\n    return a.count() * a.volume() - b.count() * b.volume();\n  });\n  pq2.contents = pq.contents; // next set - generate the median cuts using the (npix * vol) sorting.\n\n  _splitBoxes(pq2, opts.colorCount - pq2.size()); // calculate the actual colors\n\n\n  return generateSwatches(pq2);\n};\n\nfunction generateSwatches(pq) {\n  var swatches = [];\n\n  while (pq.size()) {\n    var v = pq.pop();\n    var color = v.avg();\n    var r = color[0],\n        g = color[1],\n        b = color[2];\n    swatches.push(new color_1.Swatch(color, v.count()));\n  }\n\n  return swatches;\n}\n\nexports.default = MMCQ;","map":{"version":3,"sources":["../../src/quantizer/mmcq.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar color_1 = require(\"../color\");\nvar vbox_1 = __importDefault(require(\"./vbox\"));\nvar pqueue_1 = __importDefault(require(\"./pqueue\"));\nvar fractByPopulations = 0.75;\nfunction _splitBoxes(pq, target) {\n    var lastSize = pq.size();\n    while (pq.size() < target) {\n        var vbox = pq.pop();\n        if (vbox && vbox.count() > 0) {\n            var _a = vbox.split(), vbox1 = _a[0], vbox2 = _a[1];\n            pq.push(vbox1);\n            if (vbox2 && vbox2.count() > 0)\n                pq.push(vbox2);\n            // No more new boxes, converged\n            if (pq.size() === lastSize) {\n                break;\n            }\n            else {\n                lastSize = pq.size();\n            }\n        }\n        else {\n            break;\n        }\n    }\n}\nvar MMCQ = function (pixels, opts) {\n    if (pixels.length === 0 || opts.colorCount < 2 || opts.colorCount > 256) {\n        throw new Error('Wrong MMCQ parameters');\n    }\n    var vbox = vbox_1.default.build(pixels);\n    var hist = vbox.hist;\n    var colorCount = Object.keys(hist).length;\n    var pq = new pqueue_1.default(function (a, b) { return a.count() - b.count(); });\n    pq.push(vbox);\n    // first set of colors, sorted by population\n    _splitBoxes(pq, fractByPopulations * opts.colorCount);\n    // Re-order\n    var pq2 = new pqueue_1.default(function (a, b) { return a.count() * a.volume() - b.count() * b.volume(); });\n    pq2.contents = pq.contents;\n    // next set - generate the median cuts using the (npix * vol) sorting.\n    _splitBoxes(pq2, opts.colorCount - pq2.size());\n    // calculate the actual colors\n    return generateSwatches(pq2);\n};\nfunction generateSwatches(pq) {\n    var swatches = [];\n    while (pq.size()) {\n        var v = pq.pop();\n        var color = v.avg();\n        var r = color[0], g = color[1], b = color[2];\n        swatches.push(new color_1.Swatch(color, v.count()));\n    }\n    return swatches;\n}\nexports.default = MMCQ;\n//# sourceMappingURL=mmcq.js.map"]},"metadata":{},"sourceType":"script"}