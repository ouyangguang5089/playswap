{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"/projects/testswap/uniswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/projects/testswap/uniswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/projects/testswap/uniswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/projects/testswap/uniswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/projects/testswap/uniswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport net from \"net\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nexport var IpcProvider = /*#__PURE__*/function (_JsonRpcProvider) {\n  _inherits(IpcProvider, _JsonRpcProvider);\n\n  var _super = _createSuper(IpcProvider);\n\n  function IpcProvider(path, network) {\n    var _this;\n\n    _classCallCheck(this, IpcProvider);\n\n    logger.checkNew(this instanceof IpcProvider ? this.constructor : void 0, IpcProvider);\n\n    if (path == null) {\n      logger.throwError(\"missing path\", Logger.errors.MISSING_ARGUMENT, {\n        arg: \"path\"\n      });\n    }\n\n    _this = _super.call(this, \"ipc://\" + path, network);\n    defineReadOnly(_assertThisInitialized(_this), \"path\", path);\n    return _this;\n  } // @TODO: Create a connection to the IPC path and use filters instead of polling for block\n\n\n  _createClass(IpcProvider, [{\n    key: \"send\",\n    value: function send(method, params) {\n      var _this2 = this;\n\n      // This method is very simple right now. We create a new socket\n      // connection each time, which may be slower, but the main\n      // advantage we are aiming for now is security. This simplifies\n      // multiplexing requests (since we do not need to multiplex).\n      var payload = JSON.stringify({\n        method: method,\n        params: params,\n        id: 42,\n        jsonrpc: \"2.0\"\n      });\n      return new Promise(function (resolve, reject) {\n        var response = Buffer.alloc(0);\n        var stream = net.connect(_this2.path);\n        stream.on(\"data\", function (data) {\n          response = Buffer.concat([response, data]);\n        });\n        stream.on(\"end\", function () {\n          try {\n            resolve(JSON.parse(response.toString()).result); // @TODO: Better pull apart the error\n\n            stream.destroy();\n          } catch (error) {\n            reject(error);\n            stream.destroy();\n          }\n        });\n        stream.on(\"error\", function (error) {\n          reject(error);\n          stream.destroy();\n        });\n        stream.write(payload);\n        stream.end();\n      });\n    }\n  }]);\n\n  return IpcProvider;\n}(JsonRpcProvider);","map":{"version":3,"sources":["../src.ts/ipc-provider.ts"],"names":[],"mappings":"AAAA;;;;;;;AAEA,OAAO,GAAP,MAAgB,KAAhB;AAEA,SAAS,cAAT,QAA+B,2BAA/B;AAGA,SAAS,MAAT,QAAuB,uBAAvB;AACA,SAAS,OAAT,QAAwB,YAAxB;AACA,IAAM,MAAM,GAAG,IAAI,MAAJ,CAAW,OAAX,CAAf;AAEA,SAAS,eAAT,QAAgC,qBAAhC;AAGA,WAAa,WAAb;AAAA;;AAAA;;AAGI,uBAAY,IAAZ,EAA0B,OAA1B,EAA8C;AAAA;;AAAA;;AAC1C,IAAA,MAAM,CAAC,QAAP,0DAA4B,WAA5B;;AAEA,QAAI,IAAI,IAAI,IAAZ,EAAkB;AACd,MAAA,MAAM,CAAC,UAAP,CAAkB,cAAlB,EAAkC,MAAM,CAAC,MAAP,CAAc,gBAAhD,EAAkE;AAAE,QAAA,GAAG,EAAE;AAAP,OAAlE;AACH;;AAED,8BAAM,WAAW,IAAjB,EAAuB,OAAvB;AAEA,IAAA,cAAc,gCAAO,MAAP,EAAe,IAAf,CAAd;AAT0C;AAU7C,GAbL,CAeI;;;AAfJ;AAAA;AAAA,yBAiBS,MAjBT,EAiByB,MAjBzB,EAiB2C;AAAA;;AACnC;AACA;AACA;AACA;AAEA,UAAI,OAAO,GAAG,IAAI,CAAC,SAAL,CAAe;AACzB,QAAA,MAAM,EAAE,MADiB;AAEzB,QAAA,MAAM,EAAE,MAFiB;AAGzB,QAAA,EAAE,EAAE,EAHqB;AAIzB,QAAA,OAAO,EAAE;AAJgB,OAAf,CAAd;AAOA,aAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAoB;AACnC,YAAI,QAAQ,GAAG,MAAM,CAAC,KAAP,CAAa,CAAb,CAAf;AAEA,YAAI,MAAM,GAAG,GAAG,CAAC,OAAJ,CAAY,MAAI,CAAC,IAAjB,CAAb;AAEA,QAAA,MAAM,CAAC,EAAP,CAAU,MAAV,EAAkB,UAAC,IAAD,EAAS;AACvB,UAAA,QAAQ,GAAG,MAAM,CAAC,MAAP,CAAc,CAAE,QAAF,EAAY,IAAZ,CAAd,CAAX;AACH,SAFD;AAIA,QAAA,MAAM,CAAC,EAAP,CAAU,KAAV,EAAiB,YAAK;AAClB,cAAI;AACA,YAAA,OAAO,CAAC,IAAI,CAAC,KAAL,CAAW,QAAQ,CAAC,QAAT,EAAX,EAAgC,MAAjC,CAAP,CADA,CAEA;;AACA,YAAA,MAAM,CAAC,OAAP;AACH,WAJD,CAIE,OAAO,KAAP,EAAc;AACZ,YAAA,MAAM,CAAC,KAAD,CAAN;AACA,YAAA,MAAM,CAAC,OAAP;AACH;AACJ,SATD;AAWA,QAAA,MAAM,CAAC,EAAP,CAAU,OAAV,EAAmB,UAAC,KAAD,EAAU;AACzB,UAAA,MAAM,CAAC,KAAD,CAAN;AACA,UAAA,MAAM,CAAC,OAAP;AACH,SAHD;AAKA,QAAA,MAAM,CAAC,KAAP,CAAa,OAAb;AACA,QAAA,MAAM,CAAC,GAAP;AACH,OA3BM,CAAP;AA4BH;AA1DL;;AAAA;AAAA,EAAiC,eAAjC","sourceRoot":"","sourcesContent":["\"use strict\";\nimport net from \"net\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nexport class IpcProvider extends JsonRpcProvider {\n    constructor(path, network) {\n        logger.checkNew(new.target, IpcProvider);\n        if (path == null) {\n            logger.throwError(\"missing path\", Logger.errors.MISSING_ARGUMENT, { arg: \"path\" });\n        }\n        super(\"ipc://\" + path, network);\n        defineReadOnly(this, \"path\", path);\n    }\n    // @TODO: Create a connection to the IPC path and use filters instead of polling for block\n    send(method, params) {\n        // This method is very simple right now. We create a new socket\n        // connection each time, which may be slower, but the main\n        // advantage we are aiming for now is security. This simplifies\n        // multiplexing requests (since we do not need to multiplex).\n        let payload = JSON.stringify({\n            method: method,\n            params: params,\n            id: 42,\n            jsonrpc: \"2.0\"\n        });\n        return new Promise((resolve, reject) => {\n            let response = Buffer.alloc(0);\n            let stream = net.connect(this.path);\n            stream.on(\"data\", (data) => {\n                response = Buffer.concat([response, data]);\n            });\n            stream.on(\"end\", () => {\n                try {\n                    resolve(JSON.parse(response.toString()).result);\n                    // @TODO: Better pull apart the error\n                    stream.destroy();\n                }\n                catch (error) {\n                    reject(error);\n                    stream.destroy();\n                }\n            });\n            stream.on(\"error\", (error) => {\n                reject(error);\n                stream.destroy();\n            });\n            stream.write(payload);\n            stream.end();\n        });\n    }\n}\n//# sourceMappingURL=ipc-provider.js.map"]},"metadata":{},"sourceType":"module"}