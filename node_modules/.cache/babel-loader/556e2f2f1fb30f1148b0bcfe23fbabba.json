{"ast":null,"code":"import{useEffect,useMemo}from'react';import{useDispatch,useSelector}from'react-redux';import{useActiveWeb3React}from'../../hooks';import{useBlockNumber}from'../application/hooks';import{addMulticallListeners,removeMulticallListeners,parseCallKey,toCallKey}from'./actions';function isMethodArg(x){return['string','number'].indexOf(typeof x)!==-1;}function isValidMethodArgs(x){return x===undefined||Array.isArray(x)&&x.every(function(xi){return isMethodArg(xi)||Array.isArray(xi)&&xi.every(isMethodArg);});}var INVALID_RESULT={valid:false,blockNumber:undefined,data:undefined};// use this options object\nexport var NEVER_RELOAD={blocksPerFetch:Infinity};// the lowest level call for subscribing to contract data\nfunction useCallsData(calls,options){var _useActiveWeb3React=useActiveWeb3React(),chainId=_useActiveWeb3React.chainId;var callResults=useSelector(function(state){return state.multicall.callResults;});var dispatch=useDispatch();var serializedCallKeys=useMemo(function(){var _calls$filter$map$sor,_calls$filter,_calls$filter$map;return JSON.stringify((_calls$filter$map$sor=calls===null||calls===void 0?void 0:(_calls$filter=calls.filter(function(c){return Boolean(c);}))===null||_calls$filter===void 0?void 0:(_calls$filter$map=_calls$filter.map(toCallKey))===null||_calls$filter$map===void 0?void 0:_calls$filter$map.sort())!==null&&_calls$filter$map$sor!==void 0?_calls$filter$map$sor:[]);},[calls]);// update listeners when there is an actual change that persists for at least 100ms\nuseEffect(function(){var callKeys=JSON.parse(serializedCallKeys);if(!chainId||callKeys.length===0)return undefined;var calls=callKeys.map(function(key){return parseCallKey(key);});dispatch(addMulticallListeners({chainId:chainId,calls:calls,options:options}));return function(){dispatch(removeMulticallListeners({chainId:chainId,calls:calls,options:options}));};},[chainId,dispatch,options,serializedCallKeys]);return useMemo(function(){return calls.map(function(call){var _callResults$chainId;if(!chainId||!call)return INVALID_RESULT;var result=(_callResults$chainId=callResults[chainId])===null||_callResults$chainId===void 0?void 0:_callResults$chainId[toCallKey(call)];var data;if((result===null||result===void 0?void 0:result.data)&&(result===null||result===void 0?void 0:result.data)!=='0x'){data=result.data;}return{valid:true,data:data,blockNumber:result===null||result===void 0?void 0:result.blockNumber};});},[callResults,calls,chainId]);}var INVALID_CALL_STATE={valid:false,result:undefined,loading:false,syncing:false,error:false};var LOADING_CALL_STATE={valid:true,result:undefined,loading:true,syncing:true,error:false};function toCallState(callResult,contractInterface,fragment,latestBlockNumber){if(!callResult)return INVALID_CALL_STATE;var valid=callResult.valid,data=callResult.data,blockNumber=callResult.blockNumber;if(!valid)return INVALID_CALL_STATE;if(valid&&!blockNumber)return LOADING_CALL_STATE;if(!contractInterface||!fragment||!latestBlockNumber)return LOADING_CALL_STATE;var success=data&&data.length>2;var syncing=(blockNumber!==null&&blockNumber!==void 0?blockNumber:0)<latestBlockNumber;var result=undefined;if(success&&data){try{result=contractInterface.decodeFunctionResult(fragment,data);}catch(error){console.debug('Result data parsing failed',fragment,data);return{valid:true,loading:false,error:true,syncing:syncing,result:result};}}return{valid:true,loading:false,syncing:syncing,result:result,error:!success};}export function useSingleContractMultipleData(contract,methodName,callInputs,options){var fragment=useMemo(function(){var _contract$interface;return contract===null||contract===void 0?void 0:(_contract$interface=contract.interface)===null||_contract$interface===void 0?void 0:_contract$interface.getFunction(methodName);},[contract,methodName]);var calls=useMemo(function(){return contract&&fragment&&callInputs&&callInputs.length>0?callInputs.map(function(inputs){return{address:contract.address,callData:contract.interface.encodeFunctionData(fragment,inputs)};}):[];},[callInputs,contract,fragment]);var results=useCallsData(calls,options);var latestBlockNumber=useBlockNumber();return useMemo(function(){return results.map(function(result){return toCallState(result,contract===null||contract===void 0?void 0:contract.interface,fragment,latestBlockNumber);});},[fragment,contract,results,latestBlockNumber]);}export function useMultipleContractSingleData(addresses,contractInterface,methodName,callInputs,options){var fragment=useMemo(function(){return contractInterface.getFunction(methodName);},[contractInterface,methodName]);var callData=useMemo(function(){return fragment&&isValidMethodArgs(callInputs)?contractInterface.encodeFunctionData(fragment,callInputs):undefined;},[callInputs,contractInterface,fragment]);var calls=useMemo(function(){return fragment&&addresses&&addresses.length>0&&callData?addresses.map(function(address){return address&&callData?{address:address,callData:callData}:undefined;}):[];},[addresses,callData,fragment]);var results=useCallsData(calls,options);var latestBlockNumber=useBlockNumber();return useMemo(function(){return results.map(function(result){return toCallState(result,contractInterface,fragment,latestBlockNumber);});},[fragment,results,contractInterface,latestBlockNumber]);}export function useSingleCallResult(contract,methodName,inputs,options){var fragment=useMemo(function(){var _contract$interface2;return contract===null||contract===void 0?void 0:(_contract$interface2=contract.interface)===null||_contract$interface2===void 0?void 0:_contract$interface2.getFunction(methodName);},[contract,methodName]);var calls=useMemo(function(){return contract&&fragment&&isValidMethodArgs(inputs)?[{address:contract.address,callData:contract.interface.encodeFunctionData(fragment,inputs)}]:[];},[contract,fragment,inputs]);var result=useCallsData(calls,options)[0];var latestBlockNumber=useBlockNumber();return useMemo(function(){return toCallState(result,contract===null||contract===void 0?void 0:contract.interface,fragment,latestBlockNumber);},[result,contract,fragment,latestBlockNumber]);}","map":{"version":3,"sources":["/projects/testswap/uniswap-interface/src/state/multicall/hooks.ts"],"names":["useEffect","useMemo","useDispatch","useSelector","useActiveWeb3React","useBlockNumber","addMulticallListeners","removeMulticallListeners","parseCallKey","toCallKey","isMethodArg","x","indexOf","isValidMethodArgs","undefined","Array","isArray","every","xi","INVALID_RESULT","valid","blockNumber","data","NEVER_RELOAD","blocksPerFetch","Infinity","useCallsData","calls","options","chainId","callResults","state","multicall","dispatch","serializedCallKeys","JSON","stringify","filter","c","Boolean","map","sort","callKeys","parse","length","key","call","result","INVALID_CALL_STATE","loading","syncing","error","LOADING_CALL_STATE","toCallState","callResult","contractInterface","fragment","latestBlockNumber","success","decodeFunctionResult","console","debug","useSingleContractMultipleData","contract","methodName","callInputs","interface","getFunction","inputs","address","callData","encodeFunctionData","results","useMultipleContractSingleData","addresses","useSingleCallResult"],"mappings":"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","sourcesContent":["import { Interface, FunctionFragment } from '@ethersproject/abi'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { Contract } from '@ethersproject/contracts'\nimport { useEffect, useMemo } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { useActiveWeb3React } from '../../hooks'\nimport { useBlockNumber } from '../application/hooks'\nimport { AppDispatch, AppState } from '../index'\nimport {\n  addMulticallListeners,\n  Call,\n  removeMulticallListeners,\n  parseCallKey,\n  toCallKey,\n  ListenerOptions\n} from './actions'\n\nexport interface Result extends ReadonlyArray<any> {\n  readonly [key: string]: any\n}\n\ntype MethodArg = string | number | BigNumber\ntype MethodArgs = Array<MethodArg | MethodArg[]>\n\ntype OptionalMethodInputs = Array<MethodArg | MethodArg[] | undefined> | undefined\n\nfunction isMethodArg(x: unknown): x is MethodArg {\n  return ['string', 'number'].indexOf(typeof x) !== -1\n}\n\nfunction isValidMethodArgs(x: unknown): x is MethodArgs | undefined {\n  return (\n    x === undefined ||\n    (Array.isArray(x) && x.every(xi => isMethodArg(xi) || (Array.isArray(xi) && xi.every(isMethodArg))))\n  )\n}\n\ninterface CallResult {\n  readonly valid: boolean\n  readonly data: string | undefined\n  readonly blockNumber: number | undefined\n}\n\nconst INVALID_RESULT: CallResult = { valid: false, blockNumber: undefined, data: undefined }\n\n// use this options object\nexport const NEVER_RELOAD: ListenerOptions = {\n  blocksPerFetch: Infinity\n}\n\n// the lowest level call for subscribing to contract data\nfunction useCallsData(calls: (Call | undefined)[], options?: ListenerOptions): CallResult[] {\n  const { chainId } = useActiveWeb3React()\n  const callResults = useSelector<AppState, AppState['multicall']['callResults']>(state => state.multicall.callResults)\n  const dispatch = useDispatch<AppDispatch>()\n\n  const serializedCallKeys: string = useMemo(\n    () =>\n      JSON.stringify(\n        calls\n          ?.filter((c): c is Call => Boolean(c))\n          ?.map(toCallKey)\n          ?.sort() ?? []\n      ),\n    [calls]\n  )\n\n  // update listeners when there is an actual change that persists for at least 100ms\n  useEffect(() => {\n    const callKeys: string[] = JSON.parse(serializedCallKeys)\n    if (!chainId || callKeys.length === 0) return undefined\n    const calls = callKeys.map(key => parseCallKey(key))\n    dispatch(\n      addMulticallListeners({\n        chainId,\n        calls,\n        options\n      })\n    )\n\n    return () => {\n      dispatch(\n        removeMulticallListeners({\n          chainId,\n          calls,\n          options\n        })\n      )\n    }\n  }, [chainId, dispatch, options, serializedCallKeys])\n\n  return useMemo(\n    () =>\n      calls.map<CallResult>(call => {\n        if (!chainId || !call) return INVALID_RESULT\n\n        const result = callResults[chainId]?.[toCallKey(call)]\n        let data\n        if (result?.data && result?.data !== '0x') {\n          data = result.data\n        }\n\n        return { valid: true, data, blockNumber: result?.blockNumber }\n      }),\n    [callResults, calls, chainId]\n  )\n}\n\ninterface CallState {\n  readonly valid: boolean\n  // the result, or undefined if loading or errored/no data\n  readonly result: Result | undefined\n  // true if the result has never been fetched\n  readonly loading: boolean\n  // true if the result is not for the latest block\n  readonly syncing: boolean\n  // true if the call was made and is synced, but the return data is invalid\n  readonly error: boolean\n}\n\nconst INVALID_CALL_STATE: CallState = { valid: false, result: undefined, loading: false, syncing: false, error: false }\nconst LOADING_CALL_STATE: CallState = { valid: true, result: undefined, loading: true, syncing: true, error: false }\n\nfunction toCallState(\n  callResult: CallResult | undefined,\n  contractInterface: Interface | undefined,\n  fragment: FunctionFragment | undefined,\n  latestBlockNumber: number | undefined\n): CallState {\n  if (!callResult) return INVALID_CALL_STATE\n  const { valid, data, blockNumber } = callResult\n  if (!valid) return INVALID_CALL_STATE\n  if (valid && !blockNumber) return LOADING_CALL_STATE\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE\n  const success = data && data.length > 2\n  const syncing = (blockNumber ?? 0) < latestBlockNumber\n  let result: Result | undefined = undefined\n  if (success && data) {\n    try {\n      result = contractInterface.decodeFunctionResult(fragment, data)\n    } catch (error) {\n      console.debug('Result data parsing failed', fragment, data)\n      return {\n        valid: true,\n        loading: false,\n        error: true,\n        syncing,\n        result\n      }\n    }\n  }\n  return {\n    valid: true,\n    loading: false,\n    syncing,\n    result: result,\n    error: !success\n  }\n}\n\nexport function useSingleContractMultipleData(\n  contract: Contract | null | undefined,\n  methodName: string,\n  callInputs: OptionalMethodInputs[],\n  options?: ListenerOptions\n): CallState[] {\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName])\n\n  const calls = useMemo(\n    () =>\n      contract && fragment && callInputs && callInputs.length > 0\n        ? callInputs.map<Call>(inputs => {\n            return {\n              address: contract.address,\n              callData: contract.interface.encodeFunctionData(fragment, inputs)\n            }\n          })\n        : [],\n    [callInputs, contract, fragment]\n  )\n\n  const results = useCallsData(calls, options)\n\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return results.map(result => toCallState(result, contract?.interface, fragment, latestBlockNumber))\n  }, [fragment, contract, results, latestBlockNumber])\n}\n\nexport function useMultipleContractSingleData(\n  addresses: (string | undefined)[],\n  contractInterface: Interface,\n  methodName: string,\n  callInputs?: OptionalMethodInputs,\n  options?: ListenerOptions\n): CallState[] {\n  const fragment = useMemo(() => contractInterface.getFunction(methodName), [contractInterface, methodName])\n  const callData: string | undefined = useMemo(\n    () =>\n      fragment && isValidMethodArgs(callInputs)\n        ? contractInterface.encodeFunctionData(fragment, callInputs)\n        : undefined,\n    [callInputs, contractInterface, fragment]\n  )\n\n  const calls = useMemo(\n    () =>\n      fragment && addresses && addresses.length > 0 && callData\n        ? addresses.map<Call | undefined>(address => {\n            return address && callData\n              ? {\n                  address,\n                  callData\n                }\n              : undefined\n          })\n        : [],\n    [addresses, callData, fragment]\n  )\n\n  const results = useCallsData(calls, options)\n\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return results.map(result => toCallState(result, contractInterface, fragment, latestBlockNumber))\n  }, [fragment, results, contractInterface, latestBlockNumber])\n}\n\nexport function useSingleCallResult(\n  contract: Contract | null | undefined,\n  methodName: string,\n  inputs?: OptionalMethodInputs,\n  options?: ListenerOptions\n): CallState {\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName])\n\n  const calls = useMemo<Call[]>(() => {\n    return contract && fragment && isValidMethodArgs(inputs)\n      ? [\n          {\n            address: contract.address,\n            callData: contract.interface.encodeFunctionData(fragment, inputs)\n          }\n        ]\n      : []\n  }, [contract, fragment, inputs])\n\n  const result = useCallsData(calls, options)[0]\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return toCallState(result, contract?.interface, fragment, latestBlockNumber)\n  }, [result, contract, fragment, latestBlockNumber])\n}\n"]},"metadata":{},"sourceType":"module"}