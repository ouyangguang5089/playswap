{"ast":null,"code":"import _defineProperty from\"/projects/testswap/uniswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import{ChainId,JSBI,TokenAmount,WETH,Pair}from'@uniswap/sdk';import{useMemo}from'react';import{DAI,UNI,USDC,USDT,WBTC}from'../../constants';import{STAKING_REWARDS_INTERFACE}from'../../constants/abis/staking-rewards';import{useActiveWeb3React}from'../../hooks';import{NEVER_RELOAD,useMultipleContractSingleData}from'../multicall/hooks';import{tryParseAmount}from'../swap/hooks';import useCurrentBlockTimestamp from'hooks/useCurrentBlockTimestamp';export var STAKING_GENESIS=1600387200;export var REWARDS_DURATION_DAYS=60;// TODO add staking rewards addresses here\nexport var STAKING_REWARDS_INFO=_defineProperty({},ChainId.MAINNET,[{tokens:[WETH[ChainId.MAINNET],DAI],stakingRewardAddress:'0xa1484C3aa22a66C62b77E0AE78E15258bd0cB711'},{tokens:[WETH[ChainId.MAINNET],USDC],stakingRewardAddress:'0x7FBa4B8Dc5E7616e59622806932DBea72537A56b'},{tokens:[WETH[ChainId.MAINNET],USDT],stakingRewardAddress:'0x6C3e4cb2E96B01F4b866965A91ed4437839A121a'},{tokens:[WETH[ChainId.MAINNET],WBTC],stakingRewardAddress:'0xCA35e32e7926b96A9988f61d510E038108d8068e'}]);// gets the staking info from the network for the active chain id\nexport function useStakingInfo(pairToFilterBy){var _useActiveWeb3React=useActiveWeb3React(),chainId=_useActiveWeb3React.chainId,account=_useActiveWeb3React.account;// detect if staking is ended\nvar currentBlockTimestamp=useCurrentBlockTimestamp();var info=useMemo(function(){var _STAKING_REWARDS_INFO2,_STAKING_REWARDS_INFO3;return chainId?(_STAKING_REWARDS_INFO2=(_STAKING_REWARDS_INFO3=STAKING_REWARDS_INFO[chainId])===null||_STAKING_REWARDS_INFO3===void 0?void 0:_STAKING_REWARDS_INFO3.filter(function(stakingRewardInfo){return pairToFilterBy===undefined?true:pairToFilterBy===null?false:pairToFilterBy.involvesToken(stakingRewardInfo.tokens[0])&&pairToFilterBy.involvesToken(stakingRewardInfo.tokens[1]);}))!==null&&_STAKING_REWARDS_INFO2!==void 0?_STAKING_REWARDS_INFO2:[]:[];},[chainId,pairToFilterBy]);var uni=chainId?UNI[chainId]:undefined;var rewardsAddresses=useMemo(function(){return info.map(function(_ref){var stakingRewardAddress=_ref.stakingRewardAddress;return stakingRewardAddress;});},[info]);var accountArg=useMemo(function(){return[account!==null&&account!==void 0?account:undefined];},[account]);// get all the info from the staking rewards contracts\nvar balances=useMultipleContractSingleData(rewardsAddresses,STAKING_REWARDS_INTERFACE,'balanceOf',accountArg);var earnedAmounts=useMultipleContractSingleData(rewardsAddresses,STAKING_REWARDS_INTERFACE,'earned',accountArg);var totalSupplies=useMultipleContractSingleData(rewardsAddresses,STAKING_REWARDS_INTERFACE,'totalSupply');// tokens per second, constants\nvar rewardRates=useMultipleContractSingleData(rewardsAddresses,STAKING_REWARDS_INTERFACE,'rewardRate',undefined,NEVER_RELOAD);var periodFinishes=useMultipleContractSingleData(rewardsAddresses,STAKING_REWARDS_INTERFACE,'periodFinish',undefined,NEVER_RELOAD);return useMemo(function(){if(!chainId||!uni)return[];return rewardsAddresses.reduce(function(memo,rewardsAddress,index){// these two are dependent on account\nvar balanceState=balances[index];var earnedAmountState=earnedAmounts[index];// these get fetched regardless of account\nvar totalSupplyState=totalSupplies[index];var rewardRateState=rewardRates[index];var periodFinishState=periodFinishes[index];if(// these may be undefined if not logged in\n!(balanceState===null||balanceState===void 0?void 0:balanceState.loading)&&!(earnedAmountState===null||earnedAmountState===void 0?void 0:earnedAmountState.loading)&&// always need these\ntotalSupplyState&&!totalSupplyState.loading&&rewardRateState&&!rewardRateState.loading&&periodFinishState&&!periodFinishState.loading){var _balanceState$result$,_balanceState$result,_totalSupplyState$res,_rewardRateState$resu,_periodFinishState$re,_periodFinishState$re2,_earnedAmountState$re,_earnedAmountState$re2;if((balanceState===null||balanceState===void 0?void 0:balanceState.error)||(earnedAmountState===null||earnedAmountState===void 0?void 0:earnedAmountState.error)||totalSupplyState.error||rewardRateState.error||periodFinishState.error){console.error('Failed to load staking rewards info');return memo;}// get the LP token\nvar tokens=info[index].tokens;var dummyPair=new Pair(new TokenAmount(tokens[0],'0'),new TokenAmount(tokens[1],'0'));// check for account, if no account set to 0\nvar _stakedAmount=new TokenAmount(dummyPair.liquidityToken,JSBI.BigInt((_balanceState$result$=balanceState===null||balanceState===void 0?void 0:(_balanceState$result=balanceState.result)===null||_balanceState$result===void 0?void 0:_balanceState$result[0])!==null&&_balanceState$result$!==void 0?_balanceState$result$:0));var _totalStakedAmount=new TokenAmount(dummyPair.liquidityToken,JSBI.BigInt((_totalSupplyState$res=totalSupplyState.result)===null||_totalSupplyState$res===void 0?void 0:_totalSupplyState$res[0]));var _totalRewardRate=new TokenAmount(uni,JSBI.BigInt((_rewardRateState$resu=rewardRateState.result)===null||_rewardRateState$resu===void 0?void 0:_rewardRateState$resu[0]));var getHypotheticalRewardRate=function getHypotheticalRewardRate(stakedAmount,totalStakedAmount,totalRewardRate){return new TokenAmount(uni,JSBI.greaterThan(totalStakedAmount.raw,JSBI.BigInt(0))?JSBI.divide(JSBI.multiply(totalRewardRate.raw,stakedAmount.raw),totalStakedAmount.raw):JSBI.BigInt(0));};var individualRewardRate=getHypotheticalRewardRate(_stakedAmount,_totalStakedAmount,_totalRewardRate);var periodFinishSeconds=(_periodFinishState$re=periodFinishState.result)===null||_periodFinishState$re===void 0?void 0:(_periodFinishState$re2=_periodFinishState$re[0])===null||_periodFinishState$re2===void 0?void 0:_periodFinishState$re2.toNumber();var periodFinishMs=periodFinishSeconds*1000;// compare period end timestamp vs current block timestamp (in seconds)\nvar active=periodFinishSeconds&&currentBlockTimestamp?periodFinishSeconds>currentBlockTimestamp.toNumber():true;memo.push({stakingRewardAddress:rewardsAddress,tokens:info[index].tokens,periodFinish:periodFinishMs>0?new Date(periodFinishMs):undefined,earnedAmount:new TokenAmount(uni,JSBI.BigInt((_earnedAmountState$re=earnedAmountState===null||earnedAmountState===void 0?void 0:(_earnedAmountState$re2=earnedAmountState.result)===null||_earnedAmountState$re2===void 0?void 0:_earnedAmountState$re2[0])!==null&&_earnedAmountState$re!==void 0?_earnedAmountState$re:0)),rewardRate:individualRewardRate,totalRewardRate:_totalRewardRate,stakedAmount:_stakedAmount,totalStakedAmount:_totalStakedAmount,getHypotheticalRewardRate:getHypotheticalRewardRate,active:active});}return memo;},[]);},[balances,chainId,currentBlockTimestamp,earnedAmounts,info,periodFinishes,rewardRates,rewardsAddresses,totalSupplies,uni]);}export function useTotalUniEarned(){var _useActiveWeb3React2=useActiveWeb3React(),chainId=_useActiveWeb3React2.chainId;var uni=chainId?UNI[chainId]:undefined;var stakingInfos=useStakingInfo();return useMemo(function(){var _stakingInfos$reduce;if(!uni)return undefined;return(_stakingInfos$reduce=stakingInfos===null||stakingInfos===void 0?void 0:stakingInfos.reduce(function(accumulator,stakingInfo){return accumulator.add(stakingInfo.earnedAmount);},new TokenAmount(uni,'0')))!==null&&_stakingInfos$reduce!==void 0?_stakingInfos$reduce:new TokenAmount(uni,'0');},[stakingInfos,uni]);}// based on typed value\nexport function useDerivedStakeInfo(typedValue,stakingToken,userLiquidityUnstaked){var _useActiveWeb3React3=useActiveWeb3React(),account=_useActiveWeb3React3.account;var parsedInput=tryParseAmount(typedValue,stakingToken);var parsedAmount=parsedInput&&userLiquidityUnstaked&&JSBI.lessThanOrEqual(parsedInput.raw,userLiquidityUnstaked.raw)?parsedInput:undefined;var error;if(!account){error='Connect Wallet';}if(!parsedAmount){var _error;error=(_error=error)!==null&&_error!==void 0?_error:'Enter an amount';}return{parsedAmount:parsedAmount,error:error};}// based on typed value\nexport function useDerivedUnstakeInfo(typedValue,stakingAmount){var _useActiveWeb3React4=useActiveWeb3React(),account=_useActiveWeb3React4.account;var parsedInput=tryParseAmount(typedValue,stakingAmount.token);var parsedAmount=parsedInput&&JSBI.lessThanOrEqual(parsedInput.raw,stakingAmount.raw)?parsedInput:undefined;var error;if(!account){error='Connect Wallet';}if(!parsedAmount){var _error2;error=(_error2=error)!==null&&_error2!==void 0?_error2:'Enter an amount';}return{parsedAmount:parsedAmount,error:error};}","map":{"version":3,"sources":["/projects/testswap/uniswap-interface/src/state/stake/hooks.ts"],"names":["ChainId","JSBI","TokenAmount","WETH","Pair","useMemo","DAI","UNI","USDC","USDT","WBTC","STAKING_REWARDS_INTERFACE","useActiveWeb3React","NEVER_RELOAD","useMultipleContractSingleData","tryParseAmount","useCurrentBlockTimestamp","STAKING_GENESIS","REWARDS_DURATION_DAYS","STAKING_REWARDS_INFO","MAINNET","tokens","stakingRewardAddress","useStakingInfo","pairToFilterBy","chainId","account","currentBlockTimestamp","info","filter","stakingRewardInfo","undefined","involvesToken","uni","rewardsAddresses","map","accountArg","balances","earnedAmounts","totalSupplies","rewardRates","periodFinishes","reduce","memo","rewardsAddress","index","balanceState","earnedAmountState","totalSupplyState","rewardRateState","periodFinishState","loading","error","console","dummyPair","stakedAmount","liquidityToken","BigInt","result","totalStakedAmount","totalRewardRate","getHypotheticalRewardRate","greaterThan","raw","divide","multiply","individualRewardRate","periodFinishSeconds","toNumber","periodFinishMs","active","push","periodFinish","Date","earnedAmount","rewardRate","useTotalUniEarned","stakingInfos","accumulator","stakingInfo","add","useDerivedStakeInfo","typedValue","stakingToken","userLiquidityUnstaked","parsedInput","parsedAmount","lessThanOrEqual","useDerivedUnstakeInfo","stakingAmount","token"],"mappings":"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","sourcesContent":["import { ChainId, CurrencyAmount, JSBI, Token, TokenAmount, WETH, Pair } from '@uniswap/sdk'\nimport { useMemo } from 'react'\nimport { DAI, UNI, USDC, USDT, WBTC } from '../../constants'\nimport { STAKING_REWARDS_INTERFACE } from '../../constants/abis/staking-rewards'\nimport { useActiveWeb3React } from '../../hooks'\nimport { NEVER_RELOAD, useMultipleContractSingleData } from '../multicall/hooks'\nimport { tryParseAmount } from '../swap/hooks'\nimport useCurrentBlockTimestamp from 'hooks/useCurrentBlockTimestamp'\n\nexport const STAKING_GENESIS = 1600387200\n\nexport const REWARDS_DURATION_DAYS = 60\n\n// TODO add staking rewards addresses here\nexport const STAKING_REWARDS_INFO: {\n  [chainId in ChainId]?: {\n    tokens: [Token, Token]\n    stakingRewardAddress: string\n  }[]\n} = {\n  [ChainId.MAINNET]: [\n    {\n      tokens: [WETH[ChainId.MAINNET], DAI],\n      stakingRewardAddress: '0xa1484C3aa22a66C62b77E0AE78E15258bd0cB711'\n    },\n    {\n      tokens: [WETH[ChainId.MAINNET], USDC],\n      stakingRewardAddress: '0x7FBa4B8Dc5E7616e59622806932DBea72537A56b'\n    },\n    {\n      tokens: [WETH[ChainId.MAINNET], USDT],\n      stakingRewardAddress: '0x6C3e4cb2E96B01F4b866965A91ed4437839A121a'\n    },\n    {\n      tokens: [WETH[ChainId.MAINNET], WBTC],\n      stakingRewardAddress: '0xCA35e32e7926b96A9988f61d510E038108d8068e'\n    }\n  ]\n}\n\nexport interface StakingInfo {\n  // the address of the reward contract\n  stakingRewardAddress: string\n  // the tokens involved in this pair\n  tokens: [Token, Token]\n  // the amount of token currently staked, or undefined if no account\n  stakedAmount: TokenAmount\n  // the amount of reward token earned by the active account, or undefined if no account\n  earnedAmount: TokenAmount\n  // the total amount of token staked in the contract\n  totalStakedAmount: TokenAmount\n  // the amount of token distributed per second to all LPs, constant\n  totalRewardRate: TokenAmount\n  // the current amount of token distributed to the active account per second.\n  // equivalent to percent of total supply * reward rate\n  rewardRate: TokenAmount\n  // when the period ends\n  periodFinish: Date | undefined\n  // if pool is active\n  active: boolean\n  // calculates a hypothetical amount of token distributed to the active account per second.\n  getHypotheticalRewardRate: (\n    stakedAmount: TokenAmount,\n    totalStakedAmount: TokenAmount,\n    totalRewardRate: TokenAmount\n  ) => TokenAmount\n}\n\n// gets the staking info from the network for the active chain id\nexport function useStakingInfo(pairToFilterBy?: Pair | null): StakingInfo[] {\n  const { chainId, account } = useActiveWeb3React()\n\n  // detect if staking is ended\n  const currentBlockTimestamp = useCurrentBlockTimestamp()\n\n  const info = useMemo(\n    () =>\n      chainId\n        ? STAKING_REWARDS_INFO[chainId]?.filter(stakingRewardInfo =>\n            pairToFilterBy === undefined\n              ? true\n              : pairToFilterBy === null\n              ? false\n              : pairToFilterBy.involvesToken(stakingRewardInfo.tokens[0]) &&\n                pairToFilterBy.involvesToken(stakingRewardInfo.tokens[1])\n          ) ?? []\n        : [],\n    [chainId, pairToFilterBy]\n  )\n\n  const uni = chainId ? UNI[chainId] : undefined\n\n  const rewardsAddresses = useMemo(() => info.map(({ stakingRewardAddress }) => stakingRewardAddress), [info])\n\n  const accountArg = useMemo(() => [account ?? undefined], [account])\n\n  // get all the info from the staking rewards contracts\n  const balances = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'balanceOf', accountArg)\n  const earnedAmounts = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'earned', accountArg)\n  const totalSupplies = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'totalSupply')\n\n  // tokens per second, constants\n  const rewardRates = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'rewardRate',\n    undefined,\n    NEVER_RELOAD\n  )\n  const periodFinishes = useMultipleContractSingleData(\n    rewardsAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'periodFinish',\n    undefined,\n    NEVER_RELOAD\n  )\n\n  return useMemo(() => {\n    if (!chainId || !uni) return []\n\n    return rewardsAddresses.reduce<StakingInfo[]>((memo, rewardsAddress, index) => {\n      // these two are dependent on account\n      const balanceState = balances[index]\n      const earnedAmountState = earnedAmounts[index]\n\n      // these get fetched regardless of account\n      const totalSupplyState = totalSupplies[index]\n      const rewardRateState = rewardRates[index]\n      const periodFinishState = periodFinishes[index]\n\n      if (\n        // these may be undefined if not logged in\n        !balanceState?.loading &&\n        !earnedAmountState?.loading &&\n        // always need these\n        totalSupplyState &&\n        !totalSupplyState.loading &&\n        rewardRateState &&\n        !rewardRateState.loading &&\n        periodFinishState &&\n        !periodFinishState.loading\n      ) {\n        if (\n          balanceState?.error ||\n          earnedAmountState?.error ||\n          totalSupplyState.error ||\n          rewardRateState.error ||\n          periodFinishState.error\n        ) {\n          console.error('Failed to load staking rewards info')\n          return memo\n        }\n\n        // get the LP token\n        const tokens = info[index].tokens\n        const dummyPair = new Pair(new TokenAmount(tokens[0], '0'), new TokenAmount(tokens[1], '0'))\n\n        // check for account, if no account set to 0\n\n        const stakedAmount = new TokenAmount(dummyPair.liquidityToken, JSBI.BigInt(balanceState?.result?.[0] ?? 0))\n        const totalStakedAmount = new TokenAmount(dummyPair.liquidityToken, JSBI.BigInt(totalSupplyState.result?.[0]))\n        const totalRewardRate = new TokenAmount(uni, JSBI.BigInt(rewardRateState.result?.[0]))\n\n        const getHypotheticalRewardRate = (\n          stakedAmount: TokenAmount,\n          totalStakedAmount: TokenAmount,\n          totalRewardRate: TokenAmount\n        ): TokenAmount => {\n          return new TokenAmount(\n            uni,\n            JSBI.greaterThan(totalStakedAmount.raw, JSBI.BigInt(0))\n              ? JSBI.divide(JSBI.multiply(totalRewardRate.raw, stakedAmount.raw), totalStakedAmount.raw)\n              : JSBI.BigInt(0)\n          )\n        }\n\n        const individualRewardRate = getHypotheticalRewardRate(stakedAmount, totalStakedAmount, totalRewardRate)\n\n        const periodFinishSeconds = periodFinishState.result?.[0]?.toNumber()\n        const periodFinishMs = periodFinishSeconds * 1000\n\n        // compare period end timestamp vs current block timestamp (in seconds)\n        const active =\n          periodFinishSeconds && currentBlockTimestamp ? periodFinishSeconds > currentBlockTimestamp.toNumber() : true\n\n        memo.push({\n          stakingRewardAddress: rewardsAddress,\n          tokens: info[index].tokens,\n          periodFinish: periodFinishMs > 0 ? new Date(periodFinishMs) : undefined,\n          earnedAmount: new TokenAmount(uni, JSBI.BigInt(earnedAmountState?.result?.[0] ?? 0)),\n          rewardRate: individualRewardRate,\n          totalRewardRate: totalRewardRate,\n          stakedAmount: stakedAmount,\n          totalStakedAmount: totalStakedAmount,\n          getHypotheticalRewardRate,\n          active\n        })\n      }\n      return memo\n    }, [])\n  }, [\n    balances,\n    chainId,\n    currentBlockTimestamp,\n    earnedAmounts,\n    info,\n    periodFinishes,\n    rewardRates,\n    rewardsAddresses,\n    totalSupplies,\n    uni\n  ])\n}\n\nexport function useTotalUniEarned(): TokenAmount | undefined {\n  const { chainId } = useActiveWeb3React()\n  const uni = chainId ? UNI[chainId] : undefined\n  const stakingInfos = useStakingInfo()\n\n  return useMemo(() => {\n    if (!uni) return undefined\n    return (\n      stakingInfos?.reduce(\n        (accumulator, stakingInfo) => accumulator.add(stakingInfo.earnedAmount),\n        new TokenAmount(uni, '0')\n      ) ?? new TokenAmount(uni, '0')\n    )\n  }, [stakingInfos, uni])\n}\n\n// based on typed value\nexport function useDerivedStakeInfo(\n  typedValue: string,\n  stakingToken: Token,\n  userLiquidityUnstaked: TokenAmount | undefined\n): {\n  parsedAmount?: CurrencyAmount\n  error?: string\n} {\n  const { account } = useActiveWeb3React()\n\n  const parsedInput: CurrencyAmount | undefined = tryParseAmount(typedValue, stakingToken)\n\n  const parsedAmount =\n    parsedInput && userLiquidityUnstaked && JSBI.lessThanOrEqual(parsedInput.raw, userLiquidityUnstaked.raw)\n      ? parsedInput\n      : undefined\n\n  let error: string | undefined\n  if (!account) {\n    error = 'Connect Wallet'\n  }\n  if (!parsedAmount) {\n    error = error ?? 'Enter an amount'\n  }\n\n  return {\n    parsedAmount,\n    error\n  }\n}\n\n// based on typed value\nexport function useDerivedUnstakeInfo(\n  typedValue: string,\n  stakingAmount: TokenAmount\n): {\n  parsedAmount?: CurrencyAmount\n  error?: string\n} {\n  const { account } = useActiveWeb3React()\n\n  const parsedInput: CurrencyAmount | undefined = tryParseAmount(typedValue, stakingAmount.token)\n\n  const parsedAmount = parsedInput && JSBI.lessThanOrEqual(parsedInput.raw, stakingAmount.raw) ? parsedInput : undefined\n\n  let error: string | undefined\n  if (!account) {\n    error = 'Connect Wallet'\n  }\n  if (!parsedAmount) {\n    error = error ?? 'Enter an amount'\n  }\n\n  return {\n    parsedAmount,\n    error\n  }\n}\n"]},"metadata":{},"sourceType":"module"}