{"ast":null,"code":"import _regeneratorRuntime from\"/projects/testswap/uniswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/projects/testswap/uniswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{MaxUint256}from'@ethersproject/constants';import{TokenAmount,ETHER}from'@uniswap/sdk';import{useCallback,useMemo}from'react';import{ROUTER_ADDRESS}from'../constants';import{useTokenAllowance}from'../data/Allowances';import{getTradeVersion,useV1TradeExchangeAddress}from'../data/V1';import{Field}from'../state/swap/actions';import{useTransactionAdder,useHasPendingApproval}from'../state/transactions/hooks';import{computeSlippageAdjustedAmounts}from'../utils/prices';import{calculateGasMargin}from'../utils';import{useTokenContract}from'./useContract';import{useActiveWeb3React}from'./index';import{Version}from'./useToggledVersion';export var ApprovalState;// returns a variable indicating the state of the approval and a function which approves if necessary or early returns\n(function(ApprovalState){ApprovalState[ApprovalState[\"UNKNOWN\"]=0]=\"UNKNOWN\";ApprovalState[ApprovalState[\"NOT_APPROVED\"]=1]=\"NOT_APPROVED\";ApprovalState[ApprovalState[\"PENDING\"]=2]=\"PENDING\";ApprovalState[ApprovalState[\"APPROVED\"]=3]=\"APPROVED\";})(ApprovalState||(ApprovalState={}));export function useApproveCallback(amountToApprove,spender){var _useActiveWeb3React=useActiveWeb3React(),account=_useActiveWeb3React.account;var token=amountToApprove instanceof TokenAmount?amountToApprove.token:undefined;var currentAllowance=useTokenAllowance(token,account!==null&&account!==void 0?account:undefined,spender);var pendingApproval=useHasPendingApproval(token===null||token===void 0?void 0:token.address,spender);// check the current approval status\nvar approvalState=useMemo(function(){if(!amountToApprove||!spender)return ApprovalState.UNKNOWN;if(amountToApprove.currency===ETHER)return ApprovalState.APPROVED;// we might not have enough data to know whether or not we need to approve\nif(!currentAllowance)return ApprovalState.UNKNOWN;// amountToApprove will be defined if currentAllowance is\nreturn currentAllowance.lessThan(amountToApprove)?pendingApproval?ApprovalState.PENDING:ApprovalState.NOT_APPROVED:ApprovalState.APPROVED;},[amountToApprove,currentAllowance,pendingApproval,spender]);var tokenContract=useTokenContract(token===null||token===void 0?void 0:token.address);var addTransaction=useTransactionAdder();var approve=useCallback(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var useExact,estimatedGas;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!(approvalState!==ApprovalState.NOT_APPROVED)){_context.next=3;break;}console.error('approve was called unnecessarily');return _context.abrupt(\"return\");case 3:if(token){_context.next=6;break;}console.error('no token');return _context.abrupt(\"return\");case 6:if(tokenContract){_context.next=9;break;}console.error('tokenContract is null');return _context.abrupt(\"return\");case 9:if(amountToApprove){_context.next=12;break;}console.error('missing amount to approve');return _context.abrupt(\"return\");case 12:if(spender){_context.next=15;break;}console.error('no spender');return _context.abrupt(\"return\");case 15:useExact=false;_context.next=18;return tokenContract.estimateGas.approve(spender,MaxUint256).catch(function(){// general fallback for tokens who restrict approval amounts\nuseExact=true;return tokenContract.estimateGas.approve(spender,amountToApprove.raw.toString());});case 18:estimatedGas=_context.sent;return _context.abrupt(\"return\",tokenContract.approve(spender,useExact?amountToApprove.raw.toString():MaxUint256,{gasLimit:calculateGasMargin(estimatedGas)}).then(function(response){addTransaction(response,{summary:'Approve '+amountToApprove.currency.symbol,approval:{tokenAddress:token.address,spender:spender}});}).catch(function(error){console.debug('Failed to approve token',error);throw error;}));case 20:case\"end\":return _context.stop();}}},_callee);})),[approvalState,token,tokenContract,amountToApprove,spender,addTransaction]);return[approvalState,approve];}// wraps useApproveCallback in the context of a swap\nexport function useApproveCallbackFromTrade(trade){var allowedSlippage=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var amountToApprove=useMemo(function(){return trade?computeSlippageAdjustedAmounts(trade,allowedSlippage)[Field.INPUT]:undefined;},[trade,allowedSlippage]);var tradeIsV1=getTradeVersion(trade)===Version.v1;var v1ExchangeAddress=useV1TradeExchangeAddress(trade);return useApproveCallback(amountToApprove,tradeIsV1?v1ExchangeAddress:ROUTER_ADDRESS);}","map":{"version":3,"sources":["/projects/testswap/uniswap-interface/src/hooks/useApproveCallback.ts"],"names":["MaxUint256","TokenAmount","ETHER","useCallback","useMemo","ROUTER_ADDRESS","useTokenAllowance","getTradeVersion","useV1TradeExchangeAddress","Field","useTransactionAdder","useHasPendingApproval","computeSlippageAdjustedAmounts","calculateGasMargin","useTokenContract","useActiveWeb3React","Version","ApprovalState","useApproveCallback","amountToApprove","spender","account","token","undefined","currentAllowance","pendingApproval","address","approvalState","UNKNOWN","currency","APPROVED","lessThan","PENDING","NOT_APPROVED","tokenContract","addTransaction","approve","console","error","useExact","estimateGas","catch","raw","toString","estimatedGas","gasLimit","then","response","summary","symbol","approval","tokenAddress","debug","useApproveCallbackFromTrade","trade","allowedSlippage","INPUT","tradeIsV1","v1","v1ExchangeAddress"],"mappings":"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","sourcesContent":["import { MaxUint256 } from '@ethersproject/constants'\nimport { TransactionResponse } from '@ethersproject/providers'\nimport { Trade, TokenAmount, CurrencyAmount, ETHER } from '@uniswap/sdk'\nimport { useCallback, useMemo } from 'react'\nimport { ROUTER_ADDRESS } from '../constants'\nimport { useTokenAllowance } from '../data/Allowances'\nimport { getTradeVersion, useV1TradeExchangeAddress } from '../data/V1'\nimport { Field } from '../state/swap/actions'\nimport { useTransactionAdder, useHasPendingApproval } from '../state/transactions/hooks'\nimport { computeSlippageAdjustedAmounts } from '../utils/prices'\nimport { calculateGasMargin } from '../utils'\nimport { useTokenContract } from './useContract'\nimport { useActiveWeb3React } from './index'\nimport { Version } from './useToggledVersion'\n\nexport enum ApprovalState {\n  UNKNOWN,\n  NOT_APPROVED,\n  PENDING,\n  APPROVED\n}\n\n// returns a variable indicating the state of the approval and a function which approves if necessary or early returns\nexport function useApproveCallback(\n  amountToApprove?: CurrencyAmount,\n  spender?: string\n): [ApprovalState, () => Promise<void>] {\n  const { account } = useActiveWeb3React()\n  const token = amountToApprove instanceof TokenAmount ? amountToApprove.token : undefined\n  const currentAllowance = useTokenAllowance(token, account ?? undefined, spender)\n  const pendingApproval = useHasPendingApproval(token?.address, spender)\n\n  // check the current approval status\n  const approvalState: ApprovalState = useMemo(() => {\n    if (!amountToApprove || !spender) return ApprovalState.UNKNOWN\n    if (amountToApprove.currency === ETHER) return ApprovalState.APPROVED\n    // we might not have enough data to know whether or not we need to approve\n    if (!currentAllowance) return ApprovalState.UNKNOWN\n\n    // amountToApprove will be defined if currentAllowance is\n    return currentAllowance.lessThan(amountToApprove)\n      ? pendingApproval\n        ? ApprovalState.PENDING\n        : ApprovalState.NOT_APPROVED\n      : ApprovalState.APPROVED\n  }, [amountToApprove, currentAllowance, pendingApproval, spender])\n\n  const tokenContract = useTokenContract(token?.address)\n  const addTransaction = useTransactionAdder()\n\n  const approve = useCallback(async (): Promise<void> => {\n    if (approvalState !== ApprovalState.NOT_APPROVED) {\n      console.error('approve was called unnecessarily')\n      return\n    }\n    if (!token) {\n      console.error('no token')\n      return\n    }\n\n    if (!tokenContract) {\n      console.error('tokenContract is null')\n      return\n    }\n\n    if (!amountToApprove) {\n      console.error('missing amount to approve')\n      return\n    }\n\n    if (!spender) {\n      console.error('no spender')\n      return\n    }\n\n    let useExact = false\n    const estimatedGas = await tokenContract.estimateGas.approve(spender, MaxUint256).catch(() => {\n      // general fallback for tokens who restrict approval amounts\n      useExact = true\n      return tokenContract.estimateGas.approve(spender, amountToApprove.raw.toString())\n    })\n\n    return tokenContract\n      .approve(spender, useExact ? amountToApprove.raw.toString() : MaxUint256, {\n        gasLimit: calculateGasMargin(estimatedGas)\n      })\n      .then((response: TransactionResponse) => {\n        addTransaction(response, {\n          summary: 'Approve ' + amountToApprove.currency.symbol,\n          approval: { tokenAddress: token.address, spender: spender }\n        })\n      })\n      .catch((error: Error) => {\n        console.debug('Failed to approve token', error)\n        throw error\n      })\n  }, [approvalState, token, tokenContract, amountToApprove, spender, addTransaction])\n\n  return [approvalState, approve]\n}\n\n// wraps useApproveCallback in the context of a swap\nexport function useApproveCallbackFromTrade(trade?: Trade, allowedSlippage = 0) {\n  const amountToApprove = useMemo(\n    () => (trade ? computeSlippageAdjustedAmounts(trade, allowedSlippage)[Field.INPUT] : undefined),\n    [trade, allowedSlippage]\n  )\n  const tradeIsV1 = getTradeVersion(trade) === Version.v1\n  const v1ExchangeAddress = useV1TradeExchangeAddress(trade)\n  return useApproveCallback(amountToApprove, tradeIsV1 ? v1ExchangeAddress : ROUTER_ADDRESS)\n}\n"]},"metadata":{},"sourceType":"module"}