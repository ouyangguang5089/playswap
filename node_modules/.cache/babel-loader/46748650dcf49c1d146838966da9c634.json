{"ast":null,"code":"import{useMemo}from'react';import{useAllTokenBalances}from'../../state/wallet/hooks';// compare two token amounts with highest one coming first\nfunction balanceComparator(balanceA,balanceB){if(balanceA&&balanceB){return balanceA.greaterThan(balanceB)?-1:balanceA.equalTo(balanceB)?0:1;}else if(balanceA&&balanceA.greaterThan('0')){return-1;}else if(balanceB&&balanceB.greaterThan('0')){return 1;}return 0;}function getTokenComparator(balances){return function sortTokens(tokenA,tokenB){// -1 = a is first\n// 1 = b is first\n// sort by balances\nvar balanceA=balances[tokenA.address];var balanceB=balances[tokenB.address];var balanceComp=balanceComparator(balanceA,balanceB);if(balanceComp!==0)return balanceComp;if(tokenA.symbol&&tokenB.symbol){// sort by symbol\nreturn tokenA.symbol.toLowerCase()<tokenB.symbol.toLowerCase()?-1:1;}else{return tokenA.symbol?-1:tokenB.symbol?-1:0;}};}export function useTokenComparator(inverted){var balances=useAllTokenBalances();var comparator=useMemo(function(){return getTokenComparator(balances!==null&&balances!==void 0?balances:{});},[balances]);return useMemo(function(){if(inverted){return function(tokenA,tokenB){return comparator(tokenA,tokenB)*-1;};}else{return comparator;}},[inverted,comparator]);}","map":{"version":3,"sources":["/projects/testswap/uniswap-interface/src/components/SearchModal/sorting.ts"],"names":["useMemo","useAllTokenBalances","balanceComparator","balanceA","balanceB","greaterThan","equalTo","getTokenComparator","balances","sortTokens","tokenA","tokenB","address","balanceComp","symbol","toLowerCase","useTokenComparator","inverted","comparator"],"mappings":"AACA,OAASA,OAAT,KAAwB,OAAxB,CACA,OAASC,mBAAT,KAAoC,0BAApC,CAEA;AACA,QAASC,CAAAA,iBAAT,CAA2BC,QAA3B,CAAmDC,QAAnD,CAA2E,CACzE,GAAID,QAAQ,EAAIC,QAAhB,CAA0B,CACxB,MAAOD,CAAAA,QAAQ,CAACE,WAAT,CAAqBD,QAArB,EAAiC,CAAC,CAAlC,CAAsCD,QAAQ,CAACG,OAAT,CAAiBF,QAAjB,EAA6B,CAA7B,CAAiC,CAA9E,CACD,CAFD,IAEO,IAAID,QAAQ,EAAIA,QAAQ,CAACE,WAAT,CAAqB,GAArB,CAAhB,CAA2C,CAChD,MAAO,CAAC,CAAR,CACD,CAFM,IAEA,IAAID,QAAQ,EAAIA,QAAQ,CAACC,WAAT,CAAqB,GAArB,CAAhB,CAA2C,CAChD,MAAO,EAAP,CACD,CACD,MAAO,EAAP,CACD,CAED,QAASE,CAAAA,kBAAT,CAA4BC,QAA5B,CAE6C,CAC3C,MAAO,SAASC,CAAAA,UAAT,CAAoBC,MAApB,CAAmCC,MAAnC,CAA0D,CAC/D;AACA;AAEA;AACA,GAAMR,CAAAA,QAAQ,CAAGK,QAAQ,CAACE,MAAM,CAACE,OAAR,CAAzB,CACA,GAAMR,CAAAA,QAAQ,CAAGI,QAAQ,CAACG,MAAM,CAACC,OAAR,CAAzB,CAEA,GAAMC,CAAAA,WAAW,CAAGX,iBAAiB,CAACC,QAAD,CAAWC,QAAX,CAArC,CACA,GAAIS,WAAW,GAAK,CAApB,CAAuB,MAAOA,CAAAA,WAAP,CAEvB,GAAIH,MAAM,CAACI,MAAP,EAAiBH,MAAM,CAACG,MAA5B,CAAoC,CAClC;AACA,MAAOJ,CAAAA,MAAM,CAACI,MAAP,CAAcC,WAAd,GAA8BJ,MAAM,CAACG,MAAP,CAAcC,WAAd,EAA9B,CAA4D,CAAC,CAA7D,CAAiE,CAAxE,CACD,CAHD,IAGO,CACL,MAAOL,CAAAA,MAAM,CAACI,MAAP,CAAgB,CAAC,CAAjB,CAAqBH,MAAM,CAACG,MAAP,CAAgB,CAAC,CAAjB,CAAqB,CAAjD,CACD,CACF,CAjBD,CAkBD,CAED,MAAO,SAASE,CAAAA,kBAAT,CAA4BC,QAA5B,CAAyF,CAC9F,GAAMT,CAAAA,QAAQ,CAAGP,mBAAmB,EAApC,CACA,GAAMiB,CAAAA,UAAU,CAAGlB,OAAO,CAAC,iBAAMO,CAAAA,kBAAkB,CAACC,QAAD,SAACA,QAAD,UAACA,QAAD,CAAa,EAAb,CAAxB,EAAD,CAA2C,CAACA,QAAD,CAA3C,CAA1B,CACA,MAAOR,CAAAA,OAAO,CAAC,UAAM,CACnB,GAAIiB,QAAJ,CAAc,CACZ,MAAO,UAACP,MAAD,CAAgBC,MAAhB,QAAkCO,CAAAA,UAAU,CAACR,MAAD,CAASC,MAAT,CAAV,CAA6B,CAAC,CAAhE,EAAP,CACD,CAFD,IAEO,CACL,MAAOO,CAAAA,UAAP,CACD,CACF,CANa,CAMX,CAACD,QAAD,CAAWC,UAAX,CANW,CAAd,CAOD","sourcesContent":["import { Token, TokenAmount } from '@uniswap/sdk'\nimport { useMemo } from 'react'\nimport { useAllTokenBalances } from '../../state/wallet/hooks'\n\n// compare two token amounts with highest one coming first\nfunction balanceComparator(balanceA?: TokenAmount, balanceB?: TokenAmount) {\n  if (balanceA && balanceB) {\n    return balanceA.greaterThan(balanceB) ? -1 : balanceA.equalTo(balanceB) ? 0 : 1\n  } else if (balanceA && balanceA.greaterThan('0')) {\n    return -1\n  } else if (balanceB && balanceB.greaterThan('0')) {\n    return 1\n  }\n  return 0\n}\n\nfunction getTokenComparator(balances: {\n  [tokenAddress: string]: TokenAmount | undefined\n}): (tokenA: Token, tokenB: Token) => number {\n  return function sortTokens(tokenA: Token, tokenB: Token): number {\n    // -1 = a is first\n    // 1 = b is first\n\n    // sort by balances\n    const balanceA = balances[tokenA.address]\n    const balanceB = balances[tokenB.address]\n\n    const balanceComp = balanceComparator(balanceA, balanceB)\n    if (balanceComp !== 0) return balanceComp\n\n    if (tokenA.symbol && tokenB.symbol) {\n      // sort by symbol\n      return tokenA.symbol.toLowerCase() < tokenB.symbol.toLowerCase() ? -1 : 1\n    } else {\n      return tokenA.symbol ? -1 : tokenB.symbol ? -1 : 0\n    }\n  }\n}\n\nexport function useTokenComparator(inverted: boolean): (tokenA: Token, tokenB: Token) => number {\n  const balances = useAllTokenBalances()\n  const comparator = useMemo(() => getTokenComparator(balances ?? {}), [balances])\n  return useMemo(() => {\n    if (inverted) {\n      return (tokenA: Token, tokenB: Token) => comparator(tokenA, tokenB) * -1\n    } else {\n      return comparator\n    }\n  }, [inverted, comparator])\n}\n"]},"metadata":{},"sourceType":"module"}