{"ast":null,"code":"\"use strict\";\n\nimport _regeneratorRuntime from \"/projects/testswap/uniswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport http from \"http\";\nimport https from \"https\";\nimport { parse } from \"url\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\n\nfunction getResponse(request) {\n  return new Promise(function (resolve, reject) {\n    request.once(\"response\", function (resp) {\n      var response = {\n        statusCode: resp.statusCode,\n        statusMessage: resp.statusMessage,\n        headers: Object.keys(resp.headers).reduce(function (accum, name) {\n          var value = resp.headers[name];\n\n          if (Array.isArray(value)) {\n            value = value.join(\", \");\n          }\n\n          accum[name] = value;\n          return accum;\n        }, {}),\n        body: null\n      };\n      resp.setEncoding(\"utf8\");\n      resp.on(\"data\", function (chunk) {\n        if (response.body == null) {\n          response.body = \"\";\n        }\n\n        response.body += chunk;\n      });\n      resp.on(\"end\", function () {\n        resolve(response);\n      });\n      resp.on(\"error\", function (error) {\n        /* istanbul ignore next */\n        error.response = response;\n        reject(error);\n      });\n    });\n    request.on(\"error\", function (error) {\n      reject(error);\n    });\n  });\n} // The URL.parse uses null instead of the empty string\n\n\nfunction nonnull(value) {\n  if (value == null) {\n    return \"\";\n  }\n\n  return value;\n}\n\nexport function getUrl(href, options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var url, request, req, response;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (options == null) {\n              options = {};\n            } // @TODO: Once we drop support for node 8, we can pass the href\n            //        firectly into request and skip adding the components\n            //        to this request object\n\n\n            url = parse(href);\n            request = {\n              protocol: nonnull(url.protocol),\n              hostname: nonnull(url.hostname),\n              port: nonnull(url.port),\n              path: nonnull(url.pathname) + nonnull(url.search),\n              method: options.method || \"GET\",\n              headers: options.headers || {}\n            };\n            req = null;\n            _context.t0 = nonnull(url.protocol);\n            _context.next = _context.t0 === \"http:\" ? 7 : _context.t0 === \"https:\" ? 9 : 11;\n            break;\n\n          case 7:\n            req = http.request(request);\n            return _context.abrupt(\"break\", 12);\n\n          case 9:\n            req = https.request(request);\n            return _context.abrupt(\"break\", 12);\n\n          case 11:\n            /* istanbul ignore next */\n            logger.throwError(\"unsupported protocol \".concat(url.protocol), Logger.errors.UNSUPPORTED_OPERATION, {\n              protocol: url.protocol,\n              operation: \"request\"\n            });\n\n          case 12:\n            if (options.body) {\n              req.write(options.body);\n            }\n\n            req.end();\n            _context.next = 16;\n            return getResponse(req);\n\n          case 16:\n            response = _context.sent;\n            return _context.abrupt(\"return\", response);\n\n          case 18:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}","map":{"version":3,"sources":["../src.ts/geturl.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport http from \"http\";\nimport https from \"https\";\nimport { parse } from \"url\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction getResponse(request) {\n    return new Promise((resolve, reject) => {\n        request.once(\"response\", (resp) => {\n            const response = {\n                statusCode: resp.statusCode,\n                statusMessage: resp.statusMessage,\n                headers: Object.keys(resp.headers).reduce((accum, name) => {\n                    let value = resp.headers[name];\n                    if (Array.isArray(value)) {\n                        value = value.join(\", \");\n                    }\n                    accum[name] = value;\n                    return accum;\n                }, {}),\n                body: null\n            };\n            resp.setEncoding(\"utf8\");\n            resp.on(\"data\", (chunk) => {\n                if (response.body == null) {\n                    response.body = \"\";\n                }\n                response.body += chunk;\n            });\n            resp.on(\"end\", () => {\n                resolve(response);\n            });\n            resp.on(\"error\", (error) => {\n                /* istanbul ignore next */\n                error.response = response;\n                reject(error);\n            });\n        });\n        request.on(\"error\", (error) => { reject(error); });\n    });\n}\n// The URL.parse uses null instead of the empty string\nfunction nonnull(value) {\n    if (value == null) {\n        return \"\";\n    }\n    return value;\n}\nexport function getUrl(href, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (options == null) {\n            options = {};\n        }\n        // @TODO: Once we drop support for node 8, we can pass the href\n        //        firectly into request and skip adding the components\n        //        to this request object\n        const url = parse(href);\n        const request = {\n            protocol: nonnull(url.protocol),\n            hostname: nonnull(url.hostname),\n            port: nonnull(url.port),\n            path: (nonnull(url.pathname) + nonnull(url.search)),\n            method: (options.method || \"GET\"),\n            headers: (options.headers || {}),\n        };\n        let req = null;\n        switch (nonnull(url.protocol)) {\n            case \"http:\":\n                req = http.request(request);\n                break;\n            case \"https:\":\n                req = https.request(request);\n                break;\n            default:\n                /* istanbul ignore next */\n                logger.throwError(`unsupported protocol ${url.protocol}`, Logger.errors.UNSUPPORTED_OPERATION, {\n                    protocol: url.protocol,\n                    operation: \"request\"\n                });\n        }\n        if (options.body) {\n            req.write(options.body);\n        }\n        req.end();\n        const response = yield getResponse(req);\n        return response;\n    });\n}\n//# sourceMappingURL=geturl.js.map"]},"metadata":{},"sourceType":"module"}