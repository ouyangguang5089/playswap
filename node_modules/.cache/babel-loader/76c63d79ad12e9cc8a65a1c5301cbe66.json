{"ast":null,"code":"// @ts-check\n'use strict';\n/** @typedef {import('./base').CodecFactory} CodecFactory */\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {Uint8Array}\n */\n\nvar _decode = function decode(string, alphabet, bitsPerChar) {\n  // Build the character lookup table:\n  var codes = {};\n\n  for (var i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  } // Count the padding bytes:\n\n\n  var end = string.length;\n\n  while (string[end - 1] === '=') {\n    --end;\n  } // Allocate the output:\n\n\n  var out = new Uint8Array(end * bitsPerChar / 8 | 0); // Parse the data:\n\n  var bits = 0; // Number of bits currently in the buffer\n\n  var buffer = 0; // Bits waiting to be written out, MSB first\n\n  var written = 0; // Next byte to write\n\n  for (var _i = 0; _i < end; ++_i) {\n    // Read one character from the string:\n    var value = codes[string[_i]];\n\n    if (value === undefined) {\n      throw new SyntaxError('Invalid character ' + string[_i]);\n    } // Append the bits to the buffer:\n\n\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar; // Write out some bits if the buffer has a byte's worth:\n\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 0xff & buffer >> bits;\n    }\n  } // Verify that we have received just enough bits:\n\n\n  if (bits >= bitsPerChar || 0xff & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n\n  return out;\n};\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\n\n\nvar _encode = function encode(data, alphabet, bitsPerChar) {\n  var pad = alphabet[alphabet.length - 1] === '=';\n  var mask = (1 << bitsPerChar) - 1;\n  var out = '';\n  var bits = 0; // Number of bits currently in the buffer\n\n  var buffer = 0; // Bits waiting to be written out, MSB first\n\n  for (var i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = buffer << 8 | data[i];\n    bits += 8; // Write out as much as we can:\n\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  } // Partial character:\n\n\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  } // Add padding characters until we hit a byte boundary:\n\n\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n\n  return out;\n};\n/**\n * @param {number} bitsPerChar\n * @returns {CodecFactory}\n */\n\n\nmodule.exports = function (bitsPerChar) {\n  return function (alphabet) {\n    return {\n      /**\n       * @param {Uint8Array} input\n       * @returns {string}\n       */\n      encode: function encode(input) {\n        return _encode(input, alphabet, bitsPerChar);\n      },\n\n      /**\n       * @param {string} input\n       * @returns {Uint8Array}\n       */\n      decode: function decode(input) {\n        return _decode(input, alphabet, bitsPerChar);\n      }\n    };\n  };\n};","map":{"version":3,"sources":["/projects/testswap/uniswap-interface/node_modules/multibase/src/rfc4648.js"],"names":["decode","string","alphabet","bitsPerChar","codes","i","length","end","out","Uint8Array","bits","buffer","written","value","undefined","SyntaxError","encode","data","pad","mask","module","exports","input"],"mappings":"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","sourcesContent":["// @ts-check\n'use strict'\n\n/** @typedef {import('./base').CodecFactory} CodecFactory */\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar) => {\n  // Build the character lookup table:\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError('Invalid character ' + string[i])\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * @param {number} bitsPerChar\n * @returns {CodecFactory}\n */\nmodule.exports = (bitsPerChar) => (alphabet) => {\n  return {\n    /**\n     * @param {Uint8Array} input\n     * @returns {string}\n     */\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    /**\n     * @param {string} input\n     * @returns {Uint8Array}\n     */\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}