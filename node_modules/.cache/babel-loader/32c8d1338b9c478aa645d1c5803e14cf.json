{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/projects/testswap/uniswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/projects/testswap/uniswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/projects/testswap/uniswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/projects/testswap/uniswap-interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar events_1 = tslib_1.__importDefault(require(\"events\"));\n\nvar xhr2_cookies_1 = require(\"xhr2-cookies\");\n\nvar utils_1 = require(\"@walletconnect/utils\");\n\nvar XHR = utils_1.unsafeGetFromWindow(\"XMLHttpRequest\") || xhr2_cookies_1.XMLHttpRequest;\n\nvar HTTPConnection = /*#__PURE__*/function (_events_1$default) {\n  _inherits(HTTPConnection, _events_1$default);\n\n  var _super = _createSuper(HTTPConnection);\n\n  function HTTPConnection(url) {\n    var _this;\n\n    _classCallCheck(this, HTTPConnection);\n\n    _this = _super.call(this);\n    _this.url = url;\n    return _this;\n  }\n\n  _createClass(HTTPConnection, [{\n    key: \"formatError\",\n    value: function formatError(payload, message) {\n      var code = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      return {\n        error: {\n          message: message,\n          code: code\n        },\n        id: payload.id,\n        jsonrpc: payload.jsonrpc\n      };\n    }\n  }, {\n    key: \"send\",\n    value: function send(payload, internal) {\n      var _this2 = this;\n\n      return new Promise(function (resolve) {\n        if (payload.method === \"eth_subscribe\") {\n          var error = _this2.formatError(payload, \"Subscriptions are not supported by this HTTP endpoint\");\n\n          _this2.emit(\"error\", error);\n\n          return resolve(error);\n        }\n\n        var xhr = new XHR();\n        var responded = false;\n\n        var res = function res(err, result) {\n          if (!responded) {\n            xhr.abort();\n            responded = true;\n\n            if (internal) {\n              internal(err, result);\n            } else {\n              var id = payload.id,\n                  jsonrpc = payload.jsonrpc;\n              var response = err ? {\n                id: id,\n                jsonrpc: jsonrpc,\n                error: {\n                  message: err.message,\n                  code: err.code\n                }\n              } : {\n                id: id,\n                jsonrpc: jsonrpc,\n                result: result\n              };\n\n              _this2.emit(\"payload\", response);\n\n              resolve(response);\n            }\n          }\n        };\n\n        xhr.open(\"POST\", _this2.url, true);\n        xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n        xhr.timeout = 60 * 1000;\n        xhr.onerror = res;\n        xhr.ontimeout = res;\n\n        xhr.onreadystatechange = function () {\n          if (xhr.readyState === 4) {\n            try {\n              var response = JSON.parse(xhr.responseText);\n              res(response.error, response.result);\n            } catch (e) {\n              res(e);\n            }\n          }\n        };\n\n        xhr.send(JSON.stringify(payload));\n      });\n    }\n  }]);\n\n  return HTTPConnection;\n}(events_1.default);\n\nexports.default = HTTPConnection;","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst events_1 = tslib_1.__importDefault(require(\"events\"));\nconst xhr2_cookies_1 = require(\"xhr2-cookies\");\nconst utils_1 = require(\"@walletconnect/utils\");\nconst XHR = utils_1.unsafeGetFromWindow(\"XMLHttpRequest\") || xhr2_cookies_1.XMLHttpRequest;\nclass HTTPConnection extends events_1.default {\n    constructor(url) {\n        super();\n        this.url = url;\n    }\n    formatError(payload, message, code = -1) {\n        return {\n            error: { message, code },\n            id: payload.id,\n            jsonrpc: payload.jsonrpc,\n        };\n    }\n    send(payload, internal) {\n        return new Promise(resolve => {\n            if (payload.method === \"eth_subscribe\") {\n                const error = this.formatError(payload, \"Subscriptions are not supported by this HTTP endpoint\");\n                this.emit(\"error\", error);\n                return resolve(error);\n            }\n            const xhr = new XHR();\n            let responded = false;\n            const res = (err, result) => {\n                if (!responded) {\n                    xhr.abort();\n                    responded = true;\n                    if (internal) {\n                        internal(err, result);\n                    }\n                    else {\n                        const { id, jsonrpc } = payload;\n                        const response = err\n                            ? { id, jsonrpc, error: { message: err.message, code: err.code } }\n                            : { id, jsonrpc, result };\n                        this.emit(\"payload\", response);\n                        resolve(response);\n                    }\n                }\n            };\n            xhr.open(\"POST\", this.url, true);\n            xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n            xhr.timeout = 60 * 1000;\n            xhr.onerror = res;\n            xhr.ontimeout = res;\n            xhr.onreadystatechange = () => {\n                if (xhr.readyState === 4) {\n                    try {\n                        const response = JSON.parse(xhr.responseText);\n                        res(response.error, response.result);\n                    }\n                    catch (e) {\n                        res(e);\n                    }\n                }\n            };\n            xhr.send(JSON.stringify(payload));\n        });\n    }\n}\nexports.default = HTTPConnection;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}